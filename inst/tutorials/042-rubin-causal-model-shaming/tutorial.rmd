---
title: 'Rubin Causal Model: Shaming'
author: Sophia Zhu
tutorial:
  id: rubin-causal-model-shaming
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: Exploring a data set involving attempts to increase voting in Michigan.
---

```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(primer.data)
library(skimr)
library(gt)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = "../../child_documents/copy_button.Rmd"}
```

```{r info-section, child = "../../child_documents/info_section.Rmd"}
```

<!-- Population Table vs Preceptor = more data, population talks about time? -->

<!-- reorder the hetero into sec 1 -->

## Introduction
### 

The data set `shaming` from the **primer.data** package includes data from "Social Pressure and Voter Turnout: Evidence from a Large-Scale Field Experiment" ([pdf](https://github.com/PPBDS/primer.data/blob/master/inst/papers/shaming.pdf)) by Gerber, Green, and Larimer (2008). The aim of the study was to explore to what extent people are motivated to vote by social pressure. We will be creating a Preceptor Table, several tibbles about Average Treatment Effect, as well as explore key concepts such as causal effect, assignment mechanism, and heterogeneous treatment effects. 

## Table of outcomes and covariates
### 

Using the data, we'll be making this `gt` table to find how different treatments (the postcards) and covarients impact whether people vote (primary_06).

```{r}
tibbleone <- tibble(ID = c("1", "3", "10", "48", "51", "68", "198", "323", "875", "338640"),
       ycivic = c("0","?", "?", "?","1", "?", "?","?", "?","?"),
       yhawth = c("?", "1","?", "0", "?","?","?","?", "?","?"),
       yself = c("?","?", "?", "?","?","0","1", "?", "?","?"),
       yneigh = c("?","?", "?", "?","?","?", "?","?", "1","0"),
       ycontrol = c("?", "?","0", "?","?", "?","?", "1", "?", "?"),
       Age = c("65", "55","39", "53", "38 ", "56","46", "56", "47", "72"),
       Sex = c("Male", "Male", "Male", " Male", "Female", 
               "Female", "Female", "Male", "Female", "Male")) |> 

  
  gt() |>   
  
    # Adding curly braces { } allows the entire word (i.e. civic, hawth, etc) to
    # be subscript. If we did not use the curly braces, only the first letter
    # would be subscript, which we do not want.
  
    cols_label(ycivic = md("Y<sub>civic</sub>"),
               yhawth = md("Y<sub>hawth</sub>"),
               yself = md("Y<sub>self</sub>"),
               yneigh = md("Y<sub>neigh</sub>"),
               ycontrol = md("Y<sub>control</sub>")) |> 
    tab_spanner(label = "Outcomes", c(ycivic, yhawth, yself, 
                                         yneigh, ycontrol)) |> 
    tab_spanner(label = "Covariates", c(Age, Sex))

tibbleone
```

### Exercise 1

Load in libraries **tidyverse**, **gt**, and **skimr**.

```{r table-of-outcomes-an-1, exercise = TRUE}

```

```{r table-of-outcomes-an-1-hint-1, eval = FALSE}

```

### 

The experimenters sent 5 different postcards to 180,000 households (or 180,000 units) in Michigan before the 2006 primary election. They wanted to understand if certain types of messages increase voter turnout. 

### Exercise 2

Run `glimpse()` into the data set `shaming`.

```{r table-of-outcomes-an-2, exercise = TRUE}

```

```{r table-of-outcomes-an-2-hint-1, eval = FALSE}
glimpse(shaming)
```

### 

In this experiment, the first postcard is "Civic Duty", and contained a letter telling households "to do their civic duty and vote". The second is "Hawthorne" which contained the same letter, and a notice stating that researchers were studying them. The third postcard "Self" contained everything in the Hawthorne postcard, and said that every household member would know each others' voting behaviors. The last postcard "Neighbors" would list the voting records of ALL nearby households. The "No Postcard" group did not receive post cards. 


### Exercise 3

Execute `?shaming`. 

```{r table-of-outcomes-an-3, exercise = TRUE}

```

```{r table-of-outcomes-an-3-hint-1, eval = FALSE}
?shaming
```

### 

Notice how `?shaming` gives you an explanation of the experiment, and each column! It also introduces the assignment mechanism - the process which decides whether or not a unit got a postcard, as well as what treatment postcard they got.

### Exercise 4

Type `tibble(ID = "1")` in order to create the start of the pipe which we will build into the Preceptor Table which we showed you above. The number 1 is the way that we will refer to the first person in the table, since we do not know their name.


```{r table-of-outcomes-an-4, exercise = TRUE}
 
```

For your reference, this is row 1 of the `shaming` data set

```{r}
shaming |> 
  slice(1)  
```


```{r table-of-outcomes-an-4-hint-1, eval = FALSE}
tibble(ID = "1")
```

### 

For review, you can find the basics of gt tables [here](https://gt.rstudio.com/articles/intro-creating-gt-tables.html), and by referencing the earlier tutorial.

### Exercise 5

Create another column in your tibble by adding `ytreat = "0"` after `ID = "1"`.


```{r table-of-outcomes-an-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-5-hint-1, eval = FALSE}
tibble(ID = "1",
       ytreat = "0")

```

### 

`ytreat` is the column where we input whether or not they voted (primary_06), *if they were apart of one of the treatment groups*, using a 0 or 1. 0 means that they did not vote, while 1 means that they did. However, if person 1 was part of the control (no postcard) group, we would list a "?" in the ytreat column, since we do not know whether they would have voted. 

### Exercise 6

Add a new column named `ycontrol`. Set the value of `ycontrol` to '?'.

```{r table-of-outcomes-an-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-6-hint-1, eval = FALSE}
tibble(ID = ("1"),
       ytreat = "0",
       ycontrol = "?")
```

### 

The ? in the ycontrol column is due to the Fundamental Problem of Causal Inference. Since we are already observing one potential outcome (Person 1 was given a treatment postcard), we can not also see the other potential outcome (Person 1 is not given a postcard), which is why we list it as ?. 

<!-- TM: Problem with Copy Code buttons not working from here down. -->
### Exercise 7

Let's add Person 10 into the tibble. Use `c()` to add more than one number into the column. Notice how this person is apart of the control group. How will this change the entry? 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-7, exercise = TRUE}

```

For your reference, this is row 10 of `shaming`.

```{r}
shaming |> 
  slice(10)
```

```{r table-of-outcomes-an-7-hint-1, eval = FALSE}
Remember to use c("..", "...") if you want to add more than 1 number in each column.
```

```{r table-of-outcomes-an-7-hint-2, eval = FALSE}
tibble(ID = c("1","10"),
       ytreat = c("0", "?"),
       ycontrol = c("?", "0"))
```

### 

Here, we start seeing a key assumption of Population Tables. Consider validity in the context of Preceptor Tables. Do you think the treatments of Person 1 and 10 were exactly the same? What if they saw the postcards on different days? Could seeing it on a Monday rather than a Wednesday affect their reaction? We must assume that the treatments each household receives are similar enough to be compared when using `shaming`.


<!-- add hetero -->
### 

Your table should look like this. 
```{r}
tibble(ID = c("1","10"),
       ytreat = c("0", "?"),
       ycontrol = c("?", "0"))
```

### Exercise 8

Expand your tibble by adding Person 323, 875, and 344084. Pipe `gt()` at the end to make it a gt table. 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-8, exercise = TRUE}

```

For your reference, here are the rows 

```{r}
shaming |> 
  mutate(row_number = row_number()) |> 
  filter(row_number == "323" | row_number == "875" | row_number == "344084") |> 
  relocate(row_number)
```


```{r table-of-outcomes-an-8-hint-1, eval = FALSE}
`View(shaming)` will let you see all the data.
```

```{r table-of-outcomes-an-8-hint-2, eval = FALSE}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ytreat = c("0", "?", "?", "1", "?"),
       ycontrol= c("?", "0", "1", "?", "1")) |> 
  gt()
```

### 

`View(shaming)` would have allowed you to see all the `shaming` data in a separate tab.

### 

Your table should look like this.

```{r}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ytreat = c("0", "?", "?", "1", "?"),
       ycontrol= c("?", "0", "1", "?", "1")) |> 
  gt()
```

### Exercise 9

Add columns "age" and "sex" to the tibble. Use the data from the table to fill in the rows accordingly.

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-9, exercise = TRUE}

```

Rows of `shaming`, for your reference.
```{r}
shaming |> 
  mutate(row_number = row_number()) |> 
  filter(row_number == "1" | row_number == "10" | row_number == "323" | row_number == "875" | row_number == "344084" ) |> 
  relocate(row_number)
```


```{r table-of-outcomes-an-9-hint-1, eval = FALSE}
tibble(...., 
       age = c("65","39"), 
       sex = c("Male","Male"))
```

### 

Age and sex are covariants, which are variables which could *possibly* influence whether a person votes. Other examples of covariants include income, race, and whether they voted in the previous election. 

### Exercise 10

We want to replace the column `ytreat` with the four different treated categories: `Civic Duty`, `Hawthorne`, `Self`, and `Neighbors`. Delete column `ytreat` and add column `ycivic` by adding `ycivic = c("0","?","...","...","...")` after column `ID`. Fill in the column with the correct outcomes for each ID.     

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-10, exercise = TRUE}

```

```{r}
shaming |> 
  mutate(row_number = row_number()) |> 
  filter(row_number == "1" | row_number == "10" | row_number == "323" | row_number == "875" | row_number == "344084" ) |> 
  relocate(row_number)
```

```{r table-of-outcomes-an-10-hint-1, eval = FALSE}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ycivic = c("0", "...","...", "...","..."),
       ycontrol= c("?", "0", "1", "?", "1"), 
       age = c("65", "39", "56", "47", "57"),
       ....

```

```{r table-of-outcomes-an-10-hint-2, eval = FALSE}
Recall, if we don't know the reaction of the person to something, 
we put in a "?", we like have for column `ycontrol` and `ytreat`. 
Love the Fundamental Problem of Causal Inference.
```

```{r table-of-outcomes-an-10-hint-3, eval = FALSE}
tibble(ID = c("1", "10", "323", "875", "344084"),
       ycivic = c("0", "?","?", "?","?"),
       ycontrol= c("?", "0", "1", "?", "1"), 
       age = c("65", "39", "56", "47", "57"),
       ....
```

### 

We can also consider the assumption of stability, which asks how our past data can be used in the future. This data is from the 2006 primary election, so how can I use it to find out the effect of these postcards in the 2010 primary election, or right now? To answer, we are forced to assume that households will behave in a similar way as they did in 2006.   

### Exercise 11

Create column `yhawth` below `ycivic`. Add the corresponding outcomes for each person, like you did for column `ycivic`. 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-11, exercise = TRUE}

```

```{r}
shaming |> 
  mutate(row_number = row_number()) |> 
  filter(row_number == "1" | row_number == "10" | row_number == "323" | row_number == "875" | row_number == "344084" ) |> 
  relocate(row_number)
```

```{r table-of-outcomes-an-11-hint-1, eval = FALSE}
tibble(ID = c("1","10", "323", "875", "338640"),
       ycivic = c("0", "?","?", "?","?"),
       yhawth = c("?","?","?", "?","?"),
       ycontrol = c("?","0", "1", "?", "?") ... 
```

### 

We currently only deal with 5 people (or IDs). Think back to the assumption of representiveness. Does this small sample represent the entire population? This data comes from a small neighborhood in Michigan. Could we use this data for all citizens in Michigan? For everyone in America? If we do, we must assume that our sample in this data set is large enough to represent a state. 

### Exercise 12

Add columns `yself` and `yneigh` like you did for the other two treatment columns. Add in the respective outcomes. 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-12, exercise = TRUE}

```

```{r}
shaming |> 
  mutate(row_number = row_number()) |> 
  filter(row_number == "1" | row_number == "10" | 
         row_number == "323" | row_number == "875" | 
         row_number == "344084" ) |> 
  relocate(row_number)
```

```{r table-of-outcomes-an-12-hint-1, eval = FALSE}
tibble(ID = c("1","10", "323", "875", "338640"),
       ycivic = c("0", "?","?", "?","?"),
       yhawth = c("?","?","?", "?","?"),
       yself = c("?", "?", "?", "?","?"),
       yneigh = c("?", "?", "?", "1","0"),
       ycontrol = c("?","0", "1", "?", "?")
       ....
```

### 

Notice that we can not *calculate*, as opposed to *estimate*, the average casual effect because we do not know the causal effect for each individual, because, for each individual, we can only observe, at most, one potential outcome. 


### 

Your table should look something like this
```{r}
tibble(ID = c("1","10", "323", "875", "338640"),
       ycivic = c("0", "?","?", "?","?"),
       yhawth = c("?","?","?", "?","?"),
       yself = c("?", "?", "?", "?","?"),
       yneigh = c("?", "?", "?", "1","0"),
       ycontrol = c("?","0", "1", "?", "?"),
       age = c("65","39", "56", "47", "72"),
       sex = c("Male", "Male", "Male", "Female", "Male")) |> 

  
  gt()  

```

### Exercise 13

Use `tab_spanner()` to create an overarching subtitle. Within `tab_spanner()`, set `label = "Covariants", c(age, sex)`.

```{r table-of-outcomes-an-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-13-hint-1, eval = FALSE}
The code should be placed after the gt(). Continue the pipe with |> before adding in your commands, making sure to use c() for ytreat and ycontrol. 
```

```{r table-of-outcomes-an-13-hint-2, eval = FALSE}
tibble(....) |> 
  gt() |> 
  tab_spanner(label = "Covariants", c(age, ...))
```

### 

This allows us to separate the covariants data from the outcome data to better organize the data. Think of them as subtitles of the table. 

### 

Your table should look like this
```{r}
# TM: Wrong table?
tibble(ID = c("1", "10", "323", "875", "344084"),
       ytreat = c("0", "?", "?", "1", "?"),
       ycontrol= c("?", "0", "1", "?", "1"),
       age = c("65", "39", "56", "47", "57"),
       sex = c("Male", "Male", "Male", "Female", "Female")) |> 
 
   gt() |> 
     
   tab_spanner(label = "Covariants", c(age, sex))
```

### Exercise 14

Use `tab_spanner()` to create another overarching title. Set `label = "Outcome"`, and include all the treatment columns (ycivic, yhawth, etc.) after the label, like we did with the covariants. 
```{r table-of-outcomes-an-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-14-hint-1, eval = FALSE}
tibble(....) |> 
  gt() |> 
  tab_spanner(label = "Covariants", c(age, sex)) |> 
  tab_spanner(label = "Outcomes", c(..., ...)) 
  
```

```{r table-of-outcomes-an-14-hint-2, eval = FALSE}
tibble(....) |> 
  gt() |> 
  tab_spanner(label = "Covariants", c(age, sex)) |> 
  tab_spanner(label = "Outcomes", c(ycivic, yhawth, yself, ....)) 
  
```

### 

If you want more info on gt functions that help with formatting/style, click [here](https://gt.rstudio.com/reference/index.html). Good looking tables are HOT!


### Exercise 15

Format these variables to look more professional by changing ycivic into $\sf{Y_{civic}}$ using `cols_label()` and HTML (`<sub>` and `</sub>`). The format of this function is:

````
cols_label(columnname = md("inserttext<sub>insertsubscripttext</sub>")
````

Window users may have issues with this function. If it isn't working, feel free to skip this. 

```{r table-of-outcomes-an-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-15-hint-1, eval = FALSE}
gt |>
cols_label(ycivic = md("Y<sub>civic</sub>"),
            yhawth = md("...")
           ....
```

```{r table-of-outcomes-an-15-hint-2, eval = FALSE}
gt |>
cols_label(ycivic = md("Y<sub>civic</sub>"),
            yhawth = md("Y<sub>hawth</sub>")
           ....
```

### 

Use `?gt::md` in the console if you want more info about the `md()` function, which helps with converting text into R Markdown-formatted text. Super useful for things like footnotes, fonts, currency, etc. 

### Exercise 16

Change all the other treatment labels (yhawth, yself, yneigh) in the table to have the same formatting, using `cols_label()`. 

```{r table-of-outcomes-an-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-16-hint-1, eval = FALSE}
cols_label(ycivic = md("Y<sub>civic</sub>"),
               yhawth = md("Y<sub>hawth</sub>"),
               yself = md("Y<sub>self</sub>"),
               yneigh = md("Y<sub>neigh</sub>"),
               ycontrol = md("Y<sub>control</sub>"))
```

### 

`cols_label()` can hold multiple columns within it, similar to ID. Although 

````
cols_label(ycivic = md("Y<sub>civic</sub>")) |> 
cols_label(ycontrol = md("Y<sub>control</sub>"))
````

works, you can also do 

````
cols_label(ycivic = md("Y<sub>civic</sub>"),
           yhawth = md("Y<sub>hawth</sub>")) 
````

for efficiency. 


### Exercise 17

Add Person 3, 48, 51, 68 and 198 into the table! Fill in each column as necessary.  

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-17, exercise = TRUE}

```

For your reference, the rows look like this: 

```{r}
shaming |> 
  mutate(row_number = row_number()) |> 
  filter(row_number == "3" | row_number == "48" | row_number == "51" | row_number == "68" | row_number == "198") |> 
  relocate(row_number)
```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r table-of-outcomes-an-17-hint-1, eval = FALSE}
tibble(ID = c("1", "3", "10", "48", "51", "68", "198", "323", "875", "338640"),
       ycivic = c("0","?", "?", "?","1", "?", "?","?", "?","?"),
       yhawth = c("?", "1","?", "0", "?","?","?","?", "?","?"),
       yself = c("?","?", "?", "?","?","0","1", "?", "?","?"),
       yneigh = c("?","?", "?", "?","?","?", "?","?", "1","0"),
       ycontrol = c("?", "?","0", "?","?", "?","?", "1", "?", "?")....
```

### 

Your table should look like this 
```{r}
tibbleone 
```

### 

You can also add a title using `tab_header()`. I propose the title "WOO! Peer pressure works wonders ;)"

### 

This section showed us how to create a Preceptor Table, complete with potential outcomes and covarients. We also learned more about `gt` tables, and how to style/format text within tables. 

Good job!

## Understanding shaming
###

<!-- DK: Add words of wisdom. -->

### Exercise 1

Write a paragraph that explain the shaming experiment in the context of the Rubin Causal Model. The first paragraph should use these terms: “unit,” “treatment,” “outcome,” “potential outcomes,” “casual effect,” “assignment mechanism,” and “heterogeneous treatment effects.” Do not discuss “Preceptor Tables.”  

Note: Many of these terms are defined in their respective sections in [Chapter 4](https://ppbds.github.io/primer/rubin-causal-model.html) of the Primer. All you really need to do is connect back to the `shaming` experiment. Give examples! 
```{r understanding-shamin-1}
question_text(NULL,
	message = "The shaming experiment consists of dividing the population of Michigan residents who voted in the 2004 general election into five parts. The *units* were Michigan individual voters. Half the residents were assigned to one of 5 possible *treatments*: being mailed one of four post card types or, the *control group*, being mailed nothing. The *assignment mechanism* by which the authors choose who received which post cards was random assignment. Each card contained different messages about voting. The *outcome* variable was voting (1) or not voting (0) in the 2006 primary election. Relative to the control, the largest *causal effect* --- the largest difference between the probability of voting --- was for the 'Neighbors' treatment. The causal effect of sending someone a Neighbors postcard was an increase in 8% in their likelihood of voting relative to what it would have been with no postcard. However, the treatment effect was not the same for all groups in our study population, in other words there were *heterogeneous treatment effects*. For example, the treatment effect was smaller in younger people.",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### Exercise 2

Discuss 'population.' For context, imagine you are running for governor in Indiana 2022, and you are trying to decide if this experiment is relevant to your campaign. Use the terms “representative” and “validity.”

Hint: you may find the [Cardinal Virtues section](https://ppbds.github.io/primer/probability.html#cardinal-virtues) of Chapter 5, or the [Population Table section](https://ppbds.github.io/primer/rubin-causal-model.html#population-table) of Chapter 4 to be useful. Check them out :)

```{r understanding-shamin-2}
question_text(NULL,
	message = "If I was running for governor in Indiana 2022, I would hesitate to use the experimental data. The outcome of the experiment is not relevant to my campaign. That is, it is not *valid* for my purposes. The goal is to win the election, yet the experimental data is about getting people to vote. I do not care if a postcard causes someone to vote who otherwise would not have voted. I want to cause people to vote for me! In addition, the *representativness* of the sample is a concern. The sample includes only Michigan voters, which may not be useful for making inferences about Indiana voters. In other words, the population for the study we have here does not look like the population we would have in 2022.",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

## One ATE
### 

In section 'Table of outcomes and covariates', we examine the effect of all of the postcards on a small sample of voters. This section will focus specifically on the effect of treatment `Neighbors` compared to `No Postcard` using the Average Treatment Effect (ATE). The ATE is the average difference in potential outcomes between the treated group and the control group. This number will help us compare how impactful the treatment is.

### 

We will create a tibble which looks like this:

```{r}
object_1 <- shaming |> 
  select(treatment, primary_06) |> 
  filter(treatment %in% c("Neighbors", "No Postcard")) |> 
  
  # Group by treatment so summarize() does not take the average of all 
  # treatments together, but instead for each individual treatment individually.
  
  group_by(treatment) |> 
  summarize(vote.perc = mean(primary_06), .groups = "drop")  |>

  # Use pivot_wider() to have the columns take the name of each treatment. Better
  # to visualize the avg.percent values this way.
  
  pivot_wider(names_from = treatment,
              values_from = vote.perc) |>
  
  
  # Lastly, creating a column for the ATE values. Note that the tibble is already
  # grouped by treatment so we do not need to do it here.
  
  mutate(ATE = Neighbors - `No Postcard`) |> 
  relocate(Neighbors) 
  

object_1
```

### 

The purpose of this tibble is to estimate the ATE to see how the treatment `Neighbor` compares to `No Postcard`. 

### Exercise 1

Start a new pipe with `shaming`. `select()` variables `treatment` and `primary_06`.

```{r one-ate-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-1-hint-1, eval = FALSE}
shaming |> 
  select(treatment, primary_06)
```

### 

Although it is not necessary in this case, there are many [selection helper functions](https://tidyselect.r-lib.org/reference/select_helpers.html) which are useful when working with tibbles with many columns.

 
### Exercise 2

Start a pipe with `shaming`. `filter()` for the value of `Neighbor` and `No Postcard`, which are located `%in%` treatment. 

```{r one-ate-2, exercise = TRUE}

```

```{r one-ate-2-hint-1, eval = FALSE}
Use %in% and c()
```

```{r one-ate-2-hint-2, eval = FALSE}
... |> 
  filter(treatment %in% c("No Postcard", "..."))
```

### 

Be careful about using `==` when you want to check inclusion. For example, `filter(treatment == c("No Postcard", "Neighbors"))` will work, but it is not the recommended approach.

### Exercise 3

`vote.perc` is the `mean()` of  `primary_06`. Use `summarize()` to add `vote.perc` to the tibble.

```{r one-ate-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-3-hint-1, eval = FALSE}
... |>  
  summarize(vote.perc = mean(primary_06))
```

### 

Column `vote.perc` is the percent of people who voted for ALL treatments. But we don't want to know the overall percentage. We need the percent of people who voted for each `treatment` type. 


### Exercise 4

Remove the `summarize()` line, and replace it with `group_by(treatment)` 

```{r one-ate-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-4-hint-1, eval = FALSE}
shaming |> 
  select(treatment, primary_06) |> 
  filter(treatment %in% c("No Postcard", "...")) |> 
  group_by(treatment)
```

###  

We want to `group_by()` treatment, since it takes the average of each treatment type individually. `summarize()`, on the other hand, takes the averages of all treatments together. 

### Exercise 5

Like before, create a column called `vote.perc` using `summarize()`. Set `vote.perc` equal to the `mean()` of `primary_06`, and set `.groups` equal to "drop". 


```{r one-ate-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-5-hint-1, eval = FALSE}
... |>  
  summarize(avg.percent = mean(primary_06),
           .groups = "drop")
```

### 

You can set `.groups` equal to many other things, such as "keep", which will keep the groupings you currently have in the tibble. 

### Exercise 6

Use `pivot_wider()` to make the tibble look better. Set `names_from` to `treatment`, and `values_from` to `vote.perc`.

```{r one-ate-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-6-hint-1, eval = FALSE}
... |> 
  pivot_wider(names_from = ...., 
              values_from = ....)
```

### 

`pivot_wider()` ensures that the tibble is easier to look at, by displaying all the data in one row, rather than multiple. It has several useful arguments, such as 

````
pivot_wider(names_from = variable, names_sort = TRUE/FALSE)
````

which can sort the column names (By default, the columns will be listed by order of first appearence), or 

````
pivot_wider(names_from = variable, names_glue = "{variable}_{.customvalue}"
````

which can create custom column names. More info [here](https://tidyr.tidyverse.org/reference/pivot_wider.html)

### Exercise 7

Create a new column using `mutate()` called `ATE`, by finding the difference between the treated group and control group. 

```{r one-ate-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-7-hint-1, eval = FALSE}
ATE = Subtract the value of No Postcard from Neighbors
```

```{r one-ate-7-hint-2, eval = FALSE}
... |> 
  mutate(ATE = Neighbors - `No Postcard`) 
```

### 

Remember that ATE is the average treatment effect and is the difference between the *mean* of potential outcomes (effect of treatment `Neighbors` vs effect of `No Postcard`). In this tibble, we take the mean of `primary_06` to figure out how likely a person is to vote when subjected to treatment `Neighbors`, and treatment `No Postcard`. 

### Exercise 8

Add `relocate(Neighbors)` to the end of the pipe. Once you're finished, save the tibble to `object_1`.

```{r one-ate-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-ate-8-hint-1, eval = FALSE}
... |> 
  relocate(Neighbors)
```

Recall that your tibble should look like this:

```{r}
object_1
```

### 

`relocate()` is a function that helps move a column to the leftmost position. If you don't want to move a column all the way to the left, you can use `relocate(Neighbors, .before = )` or `relocate(Neighbors, .after = )`. More on this function later. 

### 

This tibble helps you see that households that received the `Neighbors` treatment were 8% more likely to vote, compared to those that did not receive a postcard at all. 

Nice work, half way there!

## Multiple ATE
### 

In this section, we build on our previous tibble and show how each 'pair' of treatment compare to each other. We will continue to use ATE as our frame of reference when comparing treatments. ALSO REMEMBER: TREATMENT EFFECTS CAN VARY!

This is the tibble we want to recreate. 

```{r}
results <- shaming |> 
  select(treatment, primary_06) |> 
  group_by(treatment) |> 
  summarize(avg.vote = mean(primary_06), 
            .groups = "drop")
 
# crossing() and unique() are functions that might be useful. unique() returns a
# the unique values in a vector.
object_2 <- crossing(treatment = shaming$treatment, 
         control = shaming$treatment) |>
  filter(! treatment == control) |> 
  left_join(results, by = "treatment") |> 
  left_join(results, 
            by = c("control" = "treatment"), 
            suffix = c(".col_1", ".col_2")) |> 
  mutate(ATE = avg.vote.col_1 - avg.vote.col_2) |> 
  rename(col_1 = treatment) |> 
  rename(col_2 = control) |> 
  arrange(desc(ATE))

object_2
```

### Exercise 1

Select columns `treatment` and `primary_06` from data set `shaming`.

```{r multiple-ate-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r multiple-ate-1-hint, eval = FALSE}

```

### 

The object we are currently making is a causal model, rather than a predictive model. For a predictive model, we only want to *know a outcome*, such as $\sf{Y_{u}}$, whereas, for a causal model, we want to know the *function of potential outcomes*, such as the ATE.  

### Exercise 1

Start a new pipe with the `shaming` data set. `group_by()` treatment

```{r objecttwo-ex-1, exercise = TRUE}


```

```{r objecttwo-ex-1-hint, eval = FALSE}
shaming |> 
  group_by(treatment)
```

### 

Predictive models only have ONE possible outcome for each person. For example, refer back to the [brother height section](https://ppbds.github.io/primer/rubin-causal-model.html#preceptor-table). The brothers only have one predicted height, and therefore, one outcome.

### Exercise 2

Use `summarize` with the mean of primary_06, and save it to 'avg_vote'. Set `.groups` to "drop". When finished, save this as object `results`

```{r objecttwo-ex-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-2-hint, eval = FALSE}
... |> 
  summarize(avg_vote = mean(...), 
            .groups = "drop")

```

### 

Causal models, on the other hand, have at least two or more outcomes. Currently, we have two 'major' columns (control and treatment), which can be broken down even further (Civic duty, neighbor, etc.), which results in many different possible outcomes. 

### Exercise 3

Start a new pipe. Using `crossing(treatment = (...), control = (...))`, we want to find all the different possible pairs between treatment types. Replace the ... by setting both treatment and control equal to `shaming$treatment`. 

<!-- too confusing? -->

```{r objecttwo-ex-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-3-hint-1, eval = FALSE}
... 
crossing(treatment = (...$...), 
         control = (...$...)) 
```

```{r objecttwo-ex-3-hint-2, eval = FALSE}
... |> 
crossing(treatment = (shaming$treatment), 
         control = (shaming$treatment)) 
```

### 

Notice how row 1 has `No Postcard` in both the treatment and control columns. The same thing happens with `Civic Duty` in row 7, and `Hawthorne` in row 13. Let's change it so that this doesn't happen.

### Exercise 5

`filter()` results so that no entry in the treatment column is the same as an entry in the control column. We can use `!...==...` to symbolize "is not equal". 

```{r objecttwo-ex-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-5-hint-1, eval = FALSE}
... |>   
filter(! ...==...)
```

```{r objecttwo-ex-5-hint-2, eval = FALSE}
... |>   
filter(! treatment==control)
```

### 

`!=` is typically the way to symbolize "is not equal to". This also applies to various other languages, such as Python, Java, and C. It comes from the symbol $≠$ in math! 
 
### Exercise 6

Use `left_join()' to join `results` by "treatment".

```{r objecttwo-ex-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-6-hint-1, eval = FALSE}
 ... |>  
left_join(..., by = "...")

```

```{r objecttwo-ex-6-hint-2, eval = FALSE}
... |> 
left_join(results, by = "treatment")
```

### 

`left_join()` is create for combining tibbles together. However, if tibbles share a common column name, they will automatically be differentiated by adding suffixes ".x" and ".y" to the end of the name. For example, column "tibble.x" and "tibble.y". You can customize this suffix using `suffix()`.  

### Exercise 7

Pipe `left_join(results, by = c("control" = "treatment"), suffix = c(".treatment", ".control"))` to join object 'results' with our current tibble.

```{r objecttwo-ex-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-7-hint, eval = FALSE}
... |> 
left_join(results, 
            by = c("control" = "treatment"), 
            suffix = c(".treatment", ".control"))
```

### 

Formatting the code to look organized is important! 
````
left_join(results, by = c("control" = "treatment"), suffix = c(".treatment", ".control"))
````
does work, however 

````
left_join(results, 
            by = c("control" = "treatment"), 
            suffix = c(".treatment", ".control"))
````
looks better. 

### Exercise 8

Using `mutate` to create the column `ATE` by subtracting the average vote of control from the average vote of neighbor. Save your code to 'object_2'
```{r objecttwo-ex-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r objecttwo-ex-8-hint-1, eval = FALSE}
ATE = Subtract the value of avg.vote of control from the avg.vote of treatment
```

```{r objecttwo-ex-8-hint-2, eval = FALSE}
mutate(ATE = avg.vote.treatment - avg.vote.control)
```

### 

Notice how you can calculate multiple ATEs within one data set. Before, we were finding the ATE of No Postcard and Neighbor, but now we're finding the ATE of each treatment pair. 

### Exercise 9

The columns `treatment` and `control` don't really any sense anymore. Adjust the column names using `rename()` and the avg.vote suffix within `left_join()`. Feel free to change it to anything!

```{r multiple-ate-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r multiple-ate-9-hint, eval = FALSE}
... |>   
  left_join(results, by = "treatment") |> 
  left_join(results, 
            by = c("control" = "treatment"), 
            suffix = c("...", "...")) |> 
  mutate(ATE = avg.vote... - avg.vote....) |> 
  rename(.... = treatment) |> 
  ....
```

Original tibble as reference. Columns were changed to be named `col_1` and `col_2` 

```{r}
results <- shaming |> 
  select(treatment, primary_06) |> 
  group_by(treatment) |> 
  summarize(avg.vote = mean(primary_06), 
            .groups = "drop")

object_2 <- crossing(treatment = shaming$treatment, 
         control = shaming$treatment) |>
  filter(! treatment == control) |> 
  left_join(results, by = "treatment") |> 
  left_join(results, 
            by = c("control" = "treatment"), 
            suffix = c(".col_1", ".col_2")) |> 
  mutate(ATE = avg.vote.col_1 - avg.vote.col_2) |> 
  rename(col_1 = treatment) |> 
  rename(col_2 = control)
```

### 

The ATE can be also further niched down, such as the ATE of each gender, each age group, etc. You must be specific regarding what ATE you want! 

### Exercise 10

`arrange()` this tibble by ATE, in descending order. 

```{r multiple-ate-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r multiple-ate-10-hint-1, eval = FALSE}
... |> 
  arrange(...(ATE))
```

```{r multiple-ate-10-hint-2, eval = FALSE}
... |> 
  arrange(desc(ATE))
```

### 

In this section, we expanded on the tibble built in section 3, and we can now compare the effects of each treatment 'type' against each other to see the most effective method to get households to vote. Using `arrange()` on column ATE, it shows that treatment `Neighbors` is best for this job. NOTE: *Treatments effects are not always identical for different people or groups.*

## Covariate ATE
### 

For our last tibble, We will investigate whether the ATE of Neighbors and No Postcard is influenced by the covarient `age'. Units will be seperated into groups `old` and `young`. 'Old' is defined as anyone older than 64, and `young` is anyone 64 or lower.

This is the tibble we will be making.

```{r}
object_3 <- shaming |> 
  filter(treatment %in% c("Neighbors", "No Postcard")) |> 

  # Here, we use an ifelse() statement here to return "old" in the rows where
  # age is 64 # or older, and "young" elsewhere.
  
  mutate(age = ifelse(age > 64, "old", "young")) |> 

  # Group by treatment AND age here so the avg.percent values are calculated for
  # "old" and "young" separately.
  
  group_by(treatment, age) |> 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") |> 
  pivot_wider(names_from = treatment,
            values_from = avg.perc) |> 
  mutate(ATE = Neighbors - `No Postcard`) |> 
  
  # Using rename() to make the column names less confusing. We want to be specific
  # as possible. Having "No Postcard" or "Neighbors" is too confusing.

  rename("control.perc" = `No Postcard`,
         "neighbors.perc" = Neighbors) |> 
  relocate(neighbors.perc, .after = age)

object_3
```


### Exercise 1

Use `filter()` to keep the rows in which `treatment` has a value of either "No Postcard" or "Neighbors".  

```{r covariate-ate-1, exercise = TRUE}

```

```{r covariate-ate-1-hint-1, eval = FALSE}
Filter uses %in% and if you want to filter multiple variables, we use c("...","...")
```

```{r covariate-ate-1-hint-2, eval = FALSE}
shaming |> 
  filter(treatment %in% c("...", "...") )
```

### 

This object will also deal with a causal model. Although, we'd like to emphasize how, ultimately, every model is predictive, since all tables will predict at least one outcome. Causal models are more like a subtype within predictive models. 

### Exercise 2

Continue the pipe. Use `mutate` to create a column called `age` that tells us whether a person is "young" or "old" by checking if they are over 64 (old) or younger or equal to 64 (young). Use `ifelse()`. 

```{r covariate-ate-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r covariate-ate-2-hint-1, eval = FALSE}
if statements contains 3 parts within the function: 
the criteia, what happens if it returns true, and what happens if it returns false. 
Ex. (ifelse (primary_06 == 1, "they voted", "they did not vote"))

```

```{r covariate-ate-2-hint-2, eval = FALSE}
... |> 
mutate(age =ifelse(age > 64, "...", "..."))
```

```{r covariate-ate-2-hint-3, eval = FALSE}
... |> 
mutate(age =ifelse(age > 64, "old", "young"))
```

### 

Causal models allow us to figure out how the outcome the [height of each brother](https://ppbds.github.io/primer/rubin-causal-model.html#preceptor-table) will change depending on various factors such as treatment groups and covarients (ex. sports they played), which can be used to calculate the causal effect. Predictive models will not allow us to. 

### Exercise 3

`group_by` the data using both treatment and age
```{r covariate-ate-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r covariate-ate-3-hint-1, eval = FALSE}
... |> 
  group_by(treatment, age)
```

### 

Instead, if we used a predictive models, we would only able to compare the heights of each brother, since predictive models only have one possible outcome.... Boring! 

<!-- Edit this. Confusing -->

### Exercise 4

Use `summarize()` to create a new column which contains the mean of primary_06. Set .groups = "drop". 

```{r covariate-ate-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r covariate-ate-4-hint-1, eval = FALSE}
... |> 
summarize (avg.perc = mean(...),
            .groups = "drop")
```

```{r covariate-ate-4-hint-2, eval = FALSE}
... |> 
summarize (avg.perc = mean(primary_06),
            .groups = "drop")
```

### 

By grabbing the mean, we can use it to calculate ATE, which is a type of estimand. An estimand is an unknown variable, which we try to measure/calculate.

### Exercise 5

Using `pivot_wider`, clean up your table. Set the `names_from` to treatment, and `values_from` to avg.perc. 

```{r covariate-ate-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r covariate-ate-5-hint-1, eval = FALSE}
... |>   
pivot_wider(names_from = treatment,
            values_from = avg.perc)
```

### 

Estimands are the number you want to know. If you had a Preceptor Table with no missing data, you could calculate the true value of the estimand easily. Alas, you never have the full Preceptor Table. So, you need to estimate the value of the estimand. For example, the estimand wouldn't be 0.09. It would be the mean of the true (and unknown) individual causal effects. See [here](https://ppbds.github.io/primer/rubin-causal-model.html#potential-outcomes) for more.


### Exercise 6

Create a new column with `mutate`, which displays the ATE value between the two different treatment types. 

```{r covariate-ate-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r covariate-ate-6-hint-1, eval = FALSE}
You calculate the ATE by finding the difference between Neighbors and No Postcard, the two different treatment types.  
```

```{r covariate-ate-6-hint-2, eval = FALSE}
... |> 
  mutate(ATE = Neighbors - `No Postcard`)
```

### 

Recall [heterogenous treatment effects](https://ppbds.github.io/primer/rubin-causal-model.html#heterogenous-treatment-effects), and how we can only calculate the ATE since we assume that tao, or the treatment effect, is constant for every person (which goes back to validity). 

### Exercise 7

Use `relocate(Neighbors, .after = ...)` and set `.after` equal to the column we want to in front of `Neighbors`.  

```{r covariate-ate-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r covariate-ate-7-hint-1, eval = FALSE}
... |> 
relocate(Neighbors, .after = age)
```

### 

By changing `Neighbor` to be the leftmost column, it formats the table to look cleaner, since the way you calculate ATE is Neighbors - No Postcard, rather than No Postcard - Neighbors. Details matter!

### Exercise 8

Lastly, use `rename()` to change column 'No Postcard' to 'control.vote' and column 'Neighbors' into 'neighbor.vote'. Save the tibble as object_3. 

```{r covariate-ate-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r covariate-ate-8-hint-1, eval = FALSE}
... |> 
rename(...)
```

```{r covariate-ate-8-hint-2, eval = FALSE}
... |> 
rename("control.vote" = `No Postcard`,
           "neighbors.vote" = Neighbors)
```

### 

Using `rename()` makes the column names more specific. Having just "No Postcard" or "Neighbors" is too confusing.

### 

This table allows us to consider the effect of covarients when calculating ATE. We split up older people and younger people, and found out that older people are much more likely to vote! 


## Visualizing age and ATE 

Building on the previous section, We will be creating this plot to visualize the effect of age on the ATE of treatment 'Neighbor'.

```{r}
age_p <- shaming |> 
  filter(treatment %in% c("Neighbors", "No Postcard")) |> 
  filter(age < 90) |> 
  
  # We filter here because there are NA values in ages such as 102 that give us a
  # "missing rows" message when we plot our values. The plot also looks nicer this way.

  group_by(treatment, age) |> 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") |> 

  # Using arrange allows us to see show the rows that have the youngest ages 
  # first.
  
  arrange(age) |> 
  pivot_wider(names_from = treatment,
              values_from = avg.perc) |> 
  mutate(ATE = Neighbors - `No Postcard`) |> 
  rename("control.perc" = `No Postcard`,
           "neighbors.perc" = Neighbors) |> 
  ggplot(aes(x = age, y = ATE)) +
    geom_point() +
    geom_smooth(method = "loess",
                formula = y ~ x, 
                level = 0.0) +
  
    # Possibly revisit removing the gray area here because confidence intervals have
    # not been discussed yet.
  
    labs(title = "Effect on Voting of Neighbors Postcard",
        subtitle = "Average treatment effect is lower for the young and the very old",
         y = "Average Treatment Effect",
         x = "Age",
         caption = "Source: Gerber, Green, and Larimer (2008)") +
    theme_bw()

age_p
```

### Exercise 1

Start your pipe with `shaming`. `filter()` the data to only see No Postcard and Neighbors in treatment, using `%in%` as part of the code. 

```{r visualizing-age-and--1, exercise = TRUE}

```

```{r visualizing-age-and--1-hint-1, eval = FALSE}
shaming |> 
  filter(treatment %in% c("...", "..."))
```

```{r visualizing-age-and--1-hint-2, eval = FALSE}
shaming |> 
  filter(treatment %in% c("Neighbors", "No Postcard"))
```

### 

If instead of including just these two types of `treatment`, we could also exclude them both with the "not" (!) symbol:  `filter(! treatment %in% c("Hawthorne", "...", "..."))`.


### Exercise 2

`group_by()` the data by treatment and age

```{r visualizing-age-and--2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--2-hint-1, eval = FALSE}
... |> 
group_by(treatment, age)
```

### 

Looking back on the data, do you think it is biased? What if we inadvertently selected Michigan, or this neighborhood, due to outside biases? 

### Exercise 3

Calculate the `avg.perc` of of each age group by finding the mean of primary_06. Create a new column called "avg.perc" using `summarize()` to display the mean. 
```{r visualizing-age-and--3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--3-hint-1, eval = FALSE}
... |>  
summarize(avg.perc = mean(...),
            .groups = "drop")
```

### 

The previous questions ponder about the reliability the assignment mechanism (The way units are chosen to be in the treatment or control group) of `shaming`, and whether or not the potential outcomes are affected by the assignment mechanism. This is known as 'confounding'.

### Exercise 4

`arrange()` the data by age. 

```{r visualizing-age-and--4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--4-hint-1, eval = FALSE}
... |> 
arrange(age)
```

### 

Imagine: Researchers know EXACTLY how each house will react. They might inadvertently send  postcards to those  houses to get a specific result, causing the assignment mechanism is no longer be random. Within confounding, this is a subtype called selection bias.

<!-- this section doesn't flow well. chnage -->

### Exercise 5

Use `pivot_wider` to make the tibble look better. Set `names_from` as treatment and `values_from` to average perc. 

```{r visualizing-age-and--5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--5-hint-1, eval = FALSE}
... |> 
pivot_wider(names_from = ...,
              values_from = ...)
```

### 

A way to prevent confounding is by making sure that the assignment mechanism is random before the experiment starts. In the `shaming` data, scientists randomly assigned households to receive treatment postcards, and took a random sample of the population, to ensure the success of the experiment.     


### Exercise 6

Using `mutate`, create a new column called ATE, which has the ATE of treatment Neighbors and No Postcard. 

```{r visualizing-age-and--6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--6-hint-1, eval = FALSE}
ATE is calculated from subtracting the treatment group from the control group
```

```{r visualizing-age-and--6-hint-2, eval = FALSE}
... |> 
  mutate(ATE = Neighbors - `No Postcard`)
```

### 

Another thing they did was consider the statement "No causation without manipulation." We must remember that we can only measure things that can be manipulated. We can manipulate someones voting behavior, but we can not manipulate something like IQ levels.

### Exercise 7

Lets `rename` control to `control.perc`, and neighbors to `neighbor.perc`

```{r visualizing-age-and--7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--7-hint-1, eval = FALSE}
... |> 
rename("control.perc" = `No Postcard`,
         "neighbors.perc" = Neighbors)
```

### 

Your table should look like this 

```{r}
shaming |> 
  filter(treatment %in% c("Neighbors", "No Postcard")) |> 

  # We filter here because there are NA values in ages such as 102 that give us a
  # "missing rows" message when we plot our values. The plot also looks nicer this way.

  group_by(treatment, age) |> 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") |> 

  # Using arrange allows us to see show the rows that have the youngest ages 
  # first.
  
  arrange(age) |> 
  pivot_wider(names_from = treatment,
              values_from = avg.perc) |> 
  mutate(ATE = Neighbors - `No Postcard`) |> 
  rename("control.perc" = `No Postcard`,
           "neighbors.perc" = Neighbors)
```

### Exercise 8

Using ggplot, create a scatterplot with age on the x axis, and ATE on the y axis. 

```{r visualizing-age-and--8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--8-hint-1, eval = FALSE}
... |> 
ggplot(aes(x = ..., y = ...)) +
    geom_point() 
```

### 

Since we can't see what would happen if a household increased their IQ levels, we are unable to observe what would happen, showing that we must be careful on what we want to conduct studies on. Consider: How would you changed in this experiment? 

<!-- Rough. Fix.  -->

### Exercise 9

Let's add a regression line using `geom_smooth()`. Within the function, set method to "loess", formula  to y ~ x, and level to 0.0  
```{r visualizing-age-and--9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--9-hint-1, eval = FALSE}
geom_smooth(method = "loess", 
            formula = y ~ x,
            se = FALSE)
```

<!-- SZ: Correct way of removing confidence interval? DK: Use `se = FALSE`. -->

### 

R does automatically set the arguments of method and formula to 'loess' and 'y ~ x' respectively, but it's always nice to add it in. 

### Exercise 10

Adjust the feel of the graph by adding the `theme_bw()`. To finish your plot, use labs() to give the graph a title, subtitle, axes labels, legend heading, and caption.

```{r visualizing-age-and--10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--10-hint-1, eval = FALSE}
labs(title = "..."
     ....) +
  theme_bw()
```

Your graph should look like this 

```{r}
shaming |> 
  filter(treatment %in% c("Neighbors", "No Postcard")) |> 

  group_by(treatment, age) |> 
  summarize(avg.perc = mean(primary_06),
            .groups = "drop") |> 
  
  arrange(age) |> 
  pivot_wider(names_from = treatment,
              values_from = avg.perc) |> 
  mutate(ATE = Neighbors - `No Postcard`) |> 
  rename("control.perc" = `No Postcard`,
           "neighbors.perc" = Neighbors) |> 
  ggplot(aes(x = age, y = ATE)) +
    geom_point() +
    geom_smooth(method = "loess",
                formula = y ~ x) +

    labs(title = "Effect on Voting of Neighbors Postcard",
        subtitle = "Average treatment effect is lower for the young and the very old",
         y = "Average Treatment Effect",
         x = "Age",
         caption = "Source: Gerber, Green, and Larimer (2008)") +
    theme_bw()
```

### 

Notice the right hand side of the graph, the graph starts behaving strangely past ~90, and how there are messages about missing values that show up. Let's get rid of them.

### Exercise 11

`filter()` the data so that only people younger than 90 are included in the data. 

```{r visualizing-age-and--11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r visualizing-age-and--11-hint-1, eval = FALSE}
... |> 
filter(... < ...) |> 
... 
```

```{r visualizing-age-and--11-hint-2, eval = FALSE}
... |> 
filter(age < 90) |> 
... 
```

### 

Unfortunately, we are reducing the representiveness of this data by removing the 90+ population, since we do not have a large enough sample size (Ex. there is only one person who is 103 years old) to accurately predict the effect of these postcards. There is also lots of missing data.

### 

Your graph should look like this
```{r}
age_p
```

## Summary
### 

Using `shaming`, you've learned...

* Preceptor Tables
  + Potential outcomes of the treatment and control groups.
  + Causal effect (Difference between potential outcomes of the treatment group and control group)
  + Covarients 
* Key assumptions of Population tables 
  + Validity (Is the treatment effect for everyone the same?)
  + Stability (Can we use `shaming` for our next primary election?)
  + Representiveness (Does `shaming` represent all of America?) 
* A unit in the `shaming` data set is equal to one household in Michigan
* The assignment mechanism (How units chosen to be apart of the treatment group and control group)
* Fundamental Problem of Causal Inference
  + We can only see one possible outcome at a time
* Heterogeneous treatment effects 
  + TREATMENT EFFECTS WILL VARY!!!
* Average Treatment Effect (ATE)
  + Difference between the the mean of potential outcomes between the treated and control group
  + MANY DIFFERENT ATE VALUES IN ONE DATA SET 
    - Consider: Which ATE are you calculating? Of the whole data set? Of each postcard? Of each age group?
  + Is an estimand (An unknown variable which you are trying to measure)
* Difference between Causal and Predictive models 
  + Key: Predictive models only have one possible outcome, causal has two or more outcomes
* Bias within datasets 
  + Random assignment mechanisms and random sampling
  + Without them, you face 'confounding', where the assignment mechanism affects the potential outcomes 
  
### 

WOOOO! You made it, I'm proud of you buddy :)

```{r download-answers, child = "../../child_documents/download_answers.Rmd"}
```
