---
title: 'Probability: Permutation Tests'
author: Yuhan Wu
tutorial:
  id: probability-permutation-tests
output:
  learnr::tutorial:
    progressive:  true
    allow_skip::  true
runtime: shiny_prerendered
description: Explain what a permutation test is and give examples of its use.
---

```{r setup, include = FALSE}
library(learnr)
library(all.primer.tutorials)
library(tidyverse)
library(gt)
library(primer.data)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

# DK: add comments

set.seed(100)
all_assignments <- 
  expand_grid(Yao     = c(TRUE, FALSE),
              Emma    = c(TRUE, FALSE),
              Cassidy = c(TRUE, FALSE),
              Tahmid  = c(TRUE, FALSE),
              Diego   = c(TRUE, FALSE)) |>
  pivot_longer(cols = everything(),
             values_to = "treatment") |>
  mutate(control = ! treatment) |>
  mutate(assignment = rep(1:32, each = 5)) |>
  relocate(assignment, .before = name)
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

<!-- Are you Googling enough? I doubt it! Example: https://www.jwilber.me/permutationtest/ -->

<!-- Add some knowledge drops. Think of all that they learned in Chapter 4! -->


## Introduction
### 

Recall from Chapter 4 the stylized example of a Preceptor Table from the experiment which measured the causal effect of exposure to Spanish-speakers on attitudes toward immigration. 

```{r echo = FALSE}
# First, we create a tibble with the values we want for the table

tibble(subject = c("Yao", "Emma", "Cassidy", "Tahmid", "Diego"),
       ytreat = c("13", "14", "?", "?", "3"),
       ycontrol = c("?", "?", "6", "12", "?"),
       ydiff = c("?", "?", "?", "?", "?")) |>
  
  # Then, we use the gt function to make it pretty
  
  gt() |>
    tab_header(title = "Preceptor Table") |> 
    cols_label(subject = md("ID"),
                  ytreat = md("$$Y_t(u)$$"),
                  ycontrol = md("$$Y_c(u)$$"),
                  ydiff = md("$$Y_t(u) - Y_c(u)$$")) |>
    cols_move(columns = c(ytreat, ycontrol), after = c(subject)) |>
    tab_style(cell_borders(sides = "right"),
              location = cells_body(columns = c(subject))) |>
    tab_style(style = cell_text(align = "left", v_align = "middle", size = "large"), 
              locations = cells_column_labels(columns = c(subject))) |>
    cols_align(align = "center", columns = everything()) |>
    cols_align(align = "left", columns = c(subject)) |>
    tab_spanner(label = "Outcomes", c(ytreat, ycontrol)) |>
    tab_spanner(label = "Causal Effect", c(ydiff)) |>
    fmt_markdown(columns = everything())
```

Recall that the question marks indicate data we would like to have but which is missing. For example, we would like to know what Yao's attitude *would have been* if he had been given the control but we don't know that, since he was given the treatment. Similarly, we would like to know what the causal effect of the treatment is on Emma, but we don't know that because of the Fundamental Problem of Causal Inference: we can only observe one of two potential outcomes for Emma.

### 

A *permutation test* starts with the assumption that the true average treatment effect (ATE) is zero, and then calculates how "surprising" our estimated ATE is, given that assumption. If the surprise is big enough, we conclude that the ATE is not zero.

## One assignment
### 

```{r echo = FALSE}
# First section teaches students how to calculate estimated treatment effect for the data in preceptor table. 

# TRUE and value must match, FALSE and NA have to match otherwise would returns error

answer <-tibble(name = c("Yao", "Emma", "Cassidy", "Tahmid", "Diego")) |>
  mutate(treatment = c(TRUE, TRUE, FALSE, FALSE, TRUE)) |>
  mutate(control = ! treatment) |> 
  mutate(Y_t =  c(13, 14, NA ,NA ,3)) |> 
  mutate(Y_c = c(NA, NA, 6, 12, NA)) |>
  summarise(est_effect = mean(Y_t, na.rm = TRUE) - mean(Y_c, na.rm = TRUE))
```

In the experiment, Yao, Emma and Diego received the treatment while Cassidy and Tahmid did not. This "assignment" of treatments to units is only one of many possible assignments which could have, in theory, happened. The "assignment mechanism" is the process or procedure by which treatments are assigned to units. In this case, the assignment mechanism was random. Because of that, we can estimate the treatment effect by subtracting the average outcome for the controls from the average outcome of the treated. 



```{r echo = FALSE}
# First, we create a tibble with the values we want for the table

tibble(subject = c("Yao", "Emma", "Cassidy", "Tahmid", "Diego"),
       ytreat = c("13", "14", "?", "?", "3"),
       ycontrol = c("?", "?", "6", "12", "?"),
       ydiff = c("?", "?", "?", "?", "?")) |>
  
  # Then, we use the gt function to make it pretty
  
  gt() |>
    tab_header(title = "Preceptor Table") |> 
    cols_label(subject = md("ID"),
                  ytreat = md("$$Y_t(u)$$"),
                  ycontrol = md("$$Y_c(u)$$"),
                  ydiff = md("$$Y_t(u) - Y_c(u)$$")) |>
    cols_move(columns = c(ytreat, ycontrol), after = c(subject)) |>
    tab_style(cell_borders(sides = "right"),
              location = cells_body(columns = c(subject))) |>
    tab_style(style = cell_text(align = "left", v_align = "middle", size = "large"), 
              locations = cells_column_labels(columns = c(subject))) |>
    cols_align(align = "center", columns = everything()) |>
    cols_align(align = "left", columns = c(subject)) |>
    tab_spanner(label = "Outcomes", c(ytreat, ycontrol)) |>
    tab_spanner(label = "Causal Effect", c(ydiff)) |>
    fmt_markdown(columns = everything())
```

### Exercise 1

Using `tibble()` create a new variable `name` and set it equal to "Yao", "Emma", "Cassidy", "Tahmid" and "Diego" inside `c()`.

```{r one-assignment-1, exercise = TRUE}

```


```{r one-assignment-1-hint-1, eval = FALSE}
tibble(name = c("Yao", "Emma", "Cassidy", "Tahmid", "Diego"))
```

### 

We generally only include one variable made in `tibble()`. To make more columns, we will use `mutate()` to add variables.


### Exercise 2

Create a new variable `treatment` to the tibble and set it equal to TRUE, TRUE, FALSE, FALSE, TRUE using `mutate()` and `c()`

```{r one-assignment-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-assignment-2-hint-1, eval = FALSE}
tibble(name = c("Yao", "Emma", "Cassidy", "Tahmid", "Diego")) |>
  mutate(treatment = c(TRUE, TRUE, FALSE, FALSE, TRUE))
```

### 

In the experiment, Yao, Emma and Diego gets treatment, which correspond to `TRUE`, Cassidy and Tahmid gets control, which correspond to `FALSE`.

### Exercise 3

Use `mutate()` create variable `control` and set it equal to `! treatment`.

```{r one-assignment-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-assignment-3-hint-1, eval = FALSE}
... |>
  mutate(control = ! treatment)
```

### 

Now we have made our tibble which only has the combinations of treatments and control. We calls these combinations "one assignment".

### Exercise 4

Using `mutate()` create a new variable `Y_t` and set it equal to `c(13, 14, NA, NA, 3)`.

```{r one-assignment-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-assignment-4-hint-1, eval = FALSE}
...|>
  mutate(Y_t = c(13, 14, NA , NA , 3))
```

### 

We replaced the question marks with NA because we don't know the outcome if Cassidy or Tahmid were to be given the treatment.

### Exercise 5

Similarly using `mutate()` create a new variable `Y_c` and set it equal to `c(NA, NA, 6, 12, NA)`.

```{r one-assignment-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-assignment-5-hint-1, eval = FALSE}
...|>
  mutate(Y_c = c(NA, NA, 6, 12, NA))
```

### 

According to Fundamental Problem of Causal Inference we can only observe one of the possible outcomes for each individual. Therefore if we knows the value for $Y_t$ we don't know the value for $Y_c$ for the same person. And now observing the 4 columns we can see that the `TRUE` within the treatment column matches the value in column `Y_t` and the `FALSE` in treatment column match the `NA`, as well as the control columns vice verse.

### Exercise 6

Create a new variable, `t_outcome` which takes the value of `Y_t` if `treatment` equals TRUE and zero if it does not. Use `if_else()`. The three arguments for `if_else()` will be `treatment`, `Y_t` and `NA_real_`.


```{r one-assignment-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-assignment-6-hint-1, eval = FALSE}
tibble(name = c("Yao", "Emma", "Cassidy", "Tahmid", "Diego"),
  treatment = c(TRUE, TRUE, FALSE,FALSE,TRUE)) |>
  mutate(control = ! treatment) |> 
  mutate(Y_t =  c(13, 14, NA ,NA ,3)) |> 
  mutate(Y_c = c(NA, NA, 6, 12, NA)) |>
  mutate(t_outcome = if_else(treatment, Y_t, NA))

```

### 

The `if_else()` statement has three arguments, the first is an condition statement which has to correspond to an logical vector like the treatment/control column, Then if the condition statement is `TRUE`, returns the second argument, if the condition statement is `FALSE` returns the third arguments. The fact that we are allow to replace NA with 0 is that we infer a person cannot get the treatment and effect the same time, so therefore it doesn't matter which value we give, as it will be taken into consider when we calculate the estimated causal effect.

### Exercise 7

Similarly, use `mutate()` create a variable `c_outcome` and set it equal to `if_else()` which has three arguments in order, `control`, then `Y_c` , then this time use `NA`. Note that this should returns an error.

```{r one-assignment-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-assignment-7-hint-1, eval = FALSE}
tibble(name = c("Yao", "Emma", "Cassidy", "Tahmid", "Diego"),
  treatment = c(TRUE, TRUE, FALSE,FALSE,TRUE)) |>
  mutate(control = ! treatment) |> 
  mutate(Y_t =  c(13, 14, NA ,NA ,3)) |> 
  mutate(Y_c = c(NA, NA, 6, 12, NA)) |>
  mutate(t_outcome = if_else(treatment, Y_t, NA_real_)) |>
  mutate(c_outcome = if_else(control, Y_c, NA)) 
```

### 

The error message says "false` must be a double vector, not a logical vector." What this means is that the False statement in in `if_else` should be a double vector instead a logical vector like NA. 

###

There is two ways to resolve this error, first is to change `if_else` to `ifelse`, but this is not recommended because different than `if_else` which enforce that the vector for `false` must stay align with the vector for `true`. `ifelse` just tries to do the command that is "reasonable" which sometimes results in weird bug.

The second way is to replace `NA` with `NA_real_` if you run `class(NA_real_)` in Console, this would returns numeric vector which is really close to double vector.

### 

Now you should have two columns that looks exactly like the previous two columns, this is because the TRUE / FALSE matches up with the values in `Y_t` and `Y_c`, in later tutorials you will be able to observe how this might change.

### Exercise 8

Using `summarise()` create an variable `est_effect`, and set it equal to the `mean()` of `t_outcome` minus the `mean()` of `c_outcome`.  Also within both `mean()` set `na.rm` equals `TRUE`. You should get an results of $+1$

```{r one-assignment-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r one-assignment-8-hint-1, eval = FALSE}
... |>
  summarise(est_effect = mean(Y_t, na.rm = TRUE) - mean(Y_c, na.rm = TRUE))
```

### 

Using `na.rm` tells R to simply not consider the `NAs` when calculating our estimated effect, so that the mean function only calculates the rows that have *actual* values.

### 

Now what does this mean? Essentially we assume that the preceptor table is the real world data we get from some experiment, and then we calculate the *estimated treatment effect* which is $+1$. 

Now is this value (+1) sufficient to determine the effectiveness of the experiment, or in other words is this result `"surprising" enough to conclude that our treatment works. We don't know unless we've tested for all other possible combinations of assignment, and compared all possible outcomes of estimated causal effect to the value +1. 



## All assignments
### 

Although we assigned the treatment to Yao, Emma and Diego when we ran the experiment, this was not pre-ordained. Assignment was random. So, it might have been the case that we assigned the treatment to Emma and Cassidy. Since there are 5 units, and each unit could have been assignment to treatment or to control, there are a total of $2^5 = 32$ possible assignments. 

### 

In this section, we will create a tibble which specifies all possible assignments. Since each assignment requires 5 rows to specify it, the tibble has $32 * 5 = 160$ rows.


```{r}
all_assignments
```

### Exercise 1

Before we create the tibble which shows all possible combinations of treatments and controls, we first need to understand the special properties of `expand_grid()`, and how it differentiates for `tibble()`. Use `tibble()` which includes three arguments, `a = 0:1`,`b = 0:1` and ` c = 0:1`.This should creates a tibble with 2 rows

```{r all-assignments-1, exercise = TRUE}

```

```{r all-assignments-1-hint-1, eval = FALSE}
tibble(a = 0:1, b = 0:1, c = 0:1)
```

### 

`tibble()` returns 2 rows with each one of the variable returns `0` for the first row, and `1` for the second row. `tibble()` strictly follows where only creates two values for each variable *independently*.

### Exercise 2

Now use `expand_grid()` which includes three arguments, `a = 0:1`,`b = 0:1` and ` c = 0:1`.This should creates a tibble with 8 rows

```{r all-assignments-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-2-hint-1, eval = FALSE}
expand_grid(a = 0:1, b = 0:1, c = 0:1)
```

### 

Note the difference between `tibble()` and `expand_grid()`, where `tibble()` creates two rows, and `expand_grid()` creates 8 rows. `expand_grid()` is looking at the three arguments *continuously*, where it first look at variable `a` and generate 2 rows, then it match the 2 values of `b` for *each* value of `a` generate 4 rows, then it match the 2 values of `c` to the 4 rows of `a` and b` generate total of 8 rows. We use `expand_grid()` for the probability problem which we need to consider all the possible combinations of outcomes.

### Exercise 3

Use `expand_grid()` replace the variable `a`,`b` and `c` with `Yao`, `Emma` and `Cassidy`, replace `0:1` with `c(TRUE,FALSE)`. Your result should also have 8 rows.

```{r all-assignments-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-3-hint-1, eval = FALSE}
 expand_grid(Yao = c(TRUE, FALSE),
             Emma = c(TRUE, FALSE),
             Cassidy = c(TRUE,FALSE))
```

### 

This time instead of integers like 0 and 1, we use logical vectors like `TRUE` and `FALSE`.

### Exercise 4

Now add two more arguments `Tahmid` and `Diego`, and set both of them to `c(TRUE, FALSE)` as well.

```{r all-assignments-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-4-hint-1, eval = FALSE}
expand_grid(Yao = c(TRUE,FALSE),
            Emma = c(TRUE,FALSE),
            Cassidy = c(TRUE,FALSE),
            Tahmid = c(TRUE,FALSE),
            Diego = c(TRUE,FALSE))
```

### 

Now we have an complete 32*5 tibble, whith each row representing different possible outcomes. 

### Exercise 5

Use `pivot_longer()` which include two arguments, first set `cols` equal to `everything()`, then set `values_to` equal to `"treatment"`.
```{r all-assignments-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-5-hint-1, eval = FALSE}
... |>
  pivot_longer(cols = everything(),
             values_to = "treatment")
```

### 

This step allow us to combine the 5 columns in to one, `cols` means combine how many colums, `everything()` means to select every column in the tibble, but if we have 6 columns while we only want to select 5 of them we can use `c(Yao, Emma, Cassidy, Tahmid, Diego)` where we manually select the columns to pivot using `c()`.

### Exercise 6

Use `mutate()` creates a new variable `control` which is equal to `! treatment `.
```{r all-assignments-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-6-hint-1, eval = FALSE}
mutate(control = ! treatment) 
```

### 

`!` operator means "not", but since treatment is a logical vector not every`TRUE` basically means `FALSE` and vice-versa.

### Exercise 7

Using `mutate()` create a new variable `assignment` equal to `rep()` which has two arguments, with first being `1:32` and then set `each` to 5.
```{r all-assignments-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-7-hint-1, eval = FALSE}
... |>
  mutate(assignment = rep(1:32, each = 5)) 
```

### 

The `rep()` function here is slightly different than the `rep()` we've used before where the two arguments are the value and the times repeated, where we generate each number of a value a certain amount of times.


### Exercise 8

Use `relocate()` which has two arguments, the first being `assignment`, then set `.before` equal to `name`.

```{r all-assignments-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-8-hint-1, eval = FALSE}
... |>
  relocate(assignment, .before = name)
```


Now you have creates a tibble like this.
```{r}
all_assignments
```

### Exercise 9

Assign everything above to a variable `all_assignments`.
```{r all-assignments-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-9-hint-1, eval = FALSE}
all_assignments <-
  ...
```

### 

We will keep using this assignment table throughout the tutorials.

### Exercise 10

Start a pipe with `all_assignments`, use `filter()` and filter `assignment` number equal to `10`. Let's see if we can manipulate the other assignments just like what we did with the experiment data.

```{r all-assignments-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-10-hint-1, eval = FALSE}
all_assignments |>
  filter(assignment == 10)
```

### 

We have filtered in the assignment number 10, where Yao, Cassidy and Tahmid get treatment, and Emma and Diego get control.

### Exercise 11

Similar to the first section of tutorials let's adds $Y_t$ and $Y_c$ from the preceptor table in our assignment tibble. Using `mutate()` create a new variable `Y_t` and set it equal to `c(13, 14, NA, NA, 3)`.

```{r all-assignments-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-11-hint-1, eval = FALSE}
all_assignments |>
  filter(assignment == 10) |>
  mutate(Y_t = c(13, 14, NA, NA, 3))
```

### 

The `Y_t` column correspond to the $Y_t$ in preceptor table, and since we can't type quetsion mark here, we replace it with NA which both means unknown values.

### Exercise 12

Similarly use `mutate()` create a new variable `Y_c` and set it equal to `c(NA, NA, 6, 12, NA)`.

```{r all-assignments-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-12-hint-1, eval = FALSE}
all_assignments |>
  filter(assignment == 10) |>
  mutate(Y_t = c(13, 14, NA, NA, 3)) |>
  mutate(Y_c = c(NA, NA, 6, 12, NA))
```

### 

Now we have the two columns which correspond to treatment and control.

### Exercise 13

Using `mutate()` create a variable `c_outcome` and set it equal to `if_else()` which has three arguments in order, `treatment`, then `Y_t` , then `NA_real_`. 

```{r all-assignments-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-13-hint-1, eval = FALSE}
all_assignments |>
  filter(assignment == 10) |>
  mutate(Y_t = c(13, 14, NA, NA, 3)) |>
  mutate(Y_c = c(NA, NA, 6, 12, NA)) |>
  mutate(t_outcome = if_else(treatment, Y_t, NA_real_))
```

### 

You should be familiar with this step, keeping in mind that we use `NA_real_` to align with Y_t which is an double vector. 

### Exercise 14

Similarly, use `mutate()` to create a variable `c_outcome` and set it equal to `if_else()` which has three arguments in order, `control`, then `Y_c` , then `NA_real_`. This is a column with 5 NAs.

```{r all-assignments-14, exercise = TRUE}


```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-14-hint-1, eval = FALSE}
all_assignments |>
  filter(assignment == 10) |>
  mutate(Y_t = c(13, 14, NA, NA, 3)) |>
  mutate(Y_c = c(NA, NA, 6, 12, NA)) |>
  mutate(t_outcome = if_else(treatment, Y_t, NA_real_)) |>
  mutate(c_outcome = if_else(control, Y_c, NA_real_)) 
```

### 

The two columns `t_outcome` and `c_outcome` are quite abnormal, when we compared this tibble with the one in the first section below. We can see that in the `Experiment assignment` section we have `TRUE` in either treatment/control matches with values in corresponding $Y_t$ and $Y_c$, and `FALSE` match with NA, so when we start combining the two we no longer have the NAs in column `t_outcome` or `c_outcome`. However, this is different for the tibble we just creates, we can see that the `treatment` / `control` columns does not matches with the corresponding `Y_t` and `Y_c` which in the end results in with multiple NAs.

### Exercise 15

Use `summarise()` create an variable `est_effect`, and set it equal to the `mean()` of `t_outcome` minus the `mean()` of `c_outcome`.  Also within both `mean()` set `na.rm` equals `TRUE`.  You should get NaN as your results. 
```{r all-assignments-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-assignments-15-hint-1, eval = FALSE}
all_assignments |>
  filter(assignment == 10) |>
  mutate(Y_t = c(13, 14, NA, NA, 3)) |>
  mutate(Y_c = c(NA, NA, 6, 12, NA)) |>
  mutate(t_outcome = if_else(treatment, Y_t, NA_real_)) |>
  mutate(c_outcome = if_else(control, Y_c, NA_real_)) |>
  summarise(est_effect = mean(t_outcome, na.rm = TRUE) - mean(c_outcome, na.rm = TRUE))
```

### 

As expected we cannot compute with NAs or in other word, every operation that includes NA like 2 + NA will results in NA. 

### 

Now, we are stuck. We figure out in section 1 that in order to determine whether our data is sufficient enough to should that the treatment is effective we need to calculate the results of all possible combinations of the estimated treatment effect. Yet with incomplete information in the preceptor table, we cannot match the data with the assignment table which has all combinations of treatment control. Does this means that we can't solve this problem? No, as we have one way to get around with this issue, which is also the core part of *Permutation Test* and that is the *Null hypothesis*.

## Null hypothesis
```{r eval = FALSE}

# Use assignment 10 again to show how null hypothesis replace NAs with values. 

# combine_outcome is the binding of Y_t and Y_c, might considered rename it to someting treatment, then adds a replicates of it to something control to show that the two is the same.

# NA_real_ very important, otherwise would returns error.

all_assignments |>
  filter(assignment == 10) |>
  mutate(Y_t = c(13, 14, NA, NA, 3)) |>
  mutate(Y_c = c(NA, NA, 6, 12, NA)) |>
  mutate(combine_outcome = coalesce(Y_t,Y_c)) |>
  mutate(treatment_outcome = if_else(treatment, combine_outcome, NA_real_)) |>
  mutate(control_outcome =   if_else(control,   combine_outcome, NA_real_)) |>
  summarise(mean_difference = mean(treatment_outcome, na.rm = TRUE) - 
                              mean(control_outcome, na.rm = TRUE))


  

```

### 

*Let's assume that the causal effect for every unit is equal to zero. *

We are assuming that the average treatment effect is 0 and that for example, the treatment outcome for Yao is the same as the control outcome which is both 13. With this null hypothesis in place we can replace all the question marks in the preceptor table with corresponding values of the same rows, therefore, be able to calculate all other 31 possible outcomes of the `assignment` table 

We are proposing an hypothesis, that there is no difference between the outcome with treatment and the outcome with control. We can explore this hypothesis by calculating all possible outcomes of the experiment, and if the estimated treatment effect of the "real" data appears frequently during all 32 outcomes, this means that our hypothesis is correct which also means that the treatment we give is ineffective.


### Exercise 1

Write one sentence describing the what the Preceptor Table would look like if the null hypothesis is true.

```{r null-hypothesis-1}
question_text(NULL,
	message = "The two potential outcomes for each person would be the same and the column of causal effect estimates would all be zero.",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

This is the preceptor table under null hypothesis.

```{r echo = FALSE}
# First, we create a tibble with the values we want for the table

tibble(subject = c("Yao", "Emma", "Cassidy", "Tahmid", "Diego"),
       ytreat = c("13", "14", "6", "12", "3"),
       ycontrol = c("13", "14", "6", "12", "3"),
       ydiff = c("0", "0", "0", "0", "0")) |>
  
  # Then, we use the gt function to make it pretty
  
  gt() |>
    tab_header(title = "Preceptor Table",
    subtitle = "Data under the assumption that the causal effect is zero for all units") |> 
    cols_label(subject = md("ID"),
                  ytreat = md("$$Y_t(u)$$"),
                  ycontrol = md("$$Y_c(u)$$"),
                  ydiff = md("$$Y_t(u) - Y_c(u)$$")) |>
    cols_move(columns = c(ytreat, ycontrol), after = c(subject)) |>
    tab_style(cell_borders(sides = "right"),
              location = cells_body(columns = c(subject))) |>
    tab_style(style = cell_text(align = "left", v_align = "middle", size = "large"), 
              locations = cells_column_labels(columns = c(subject))) |>
    cols_align(align = "center", columns = everything()) |>
    cols_align(align = "left", columns = c(subject)) |>
    tab_spanner(label = "Outcomes", c(ytreat, ycontrol)) |>
    tab_spanner(label = "Causal Effect", c(ydiff)) |>
    fmt_markdown(columns = everything())
```

### Exercise 2

Let's calculate the estimated treatment effect with Assignment Number 10 again to find if the null hypothesis is correct. Start a pipe with `all_assignments`, and use `filter()` and filter `assignment` equal to number `10`.

```{r null-hypothesis-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r null-hypothesis-2-hint-1, eval = FALSE}
all_assignments |>
  filter(assignment == 10)
```

### Exercise 3

Using `mutate()` create a new variable `Y_t` and set it equal to `c(13, 14, NA, NA, 3)`.

```{r null-hypothesis-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r null-hypothesis-3-hint-1, eval = FALSE}
... |>
  mutate(Y_t = c(13, 14, NA, NA, 3))
```

### Exercise 4

Similarly using `mutate()` create a new variable `Y_c` and set it equal to `c(NA, NA, 6, 12, NA)`.
```{r null-hypothesis-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r null-hypothesis-4-hint-1, eval = FALSE}
... |>
   mutate(Y_c = c(NA, NA, 6, 12, NA))
```

### 

Up until now everything is the same as before. If we assume that the null hypothesis is true in which the values of treatment are equal to the value of control, we will "combine" the two columns to eliminate the NA values.

### Exercise 5

Use `mutate()` to create a new variable `combine_outcome` and set it equal to `coalesce()` which takes on two arguments, `Y_t` and `Y_c`
```{r null-hypothesis-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r null-hypothesis-5-hint-1, eval = FALSE}
... |>
   mutate(combine_outcome = coalesce(Y_t,Y_c))
```

### 

The `combine_outcome` column is our treatment and control outcomes under null hypothesis, as they are exactly identical so we don't need to create a new column (even though we could) to specify treatment or control.

### Exercise 6

Use `mutate()` to create a variable `treatment_outcome` and set it equal to `if_else()` which has three arguments in order, `treatment`, then `combine_outcome` , then `NA_real_` similar to the previous section. 

```{r null-hypothesis-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r null-hypothesis-6-hint-1, eval = FALSE}
... |> 
  mutate(treatment_outcome = if_else(treatment, combine_outcome, NA_real_))
```

### Exercise 7

Use `mutate()` to create a variable `control_outcome` and set it equal to `if_else()` which the three arguments `control`, `combine`, and `NA_real_`.

```{r null-hypothesis-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r null-hypothesis-7-hint-1, eval = FALSE}
... |>
   mutate(control_outcome =   if_else(control,   combine_outcome, NA_real_))
```

### 

Looking at the two columns we just created, it is much nicer than the same one we created in previous sections. In `treatment_outcome` we can see that every `TRUE` under `treatment` gets an value, as well as for `control_outcome`. Every `FALSE` also gets the corresponding NA.

### Exercise 8

Use `summarise()` to create an variable `mean_difference`, and set it equal to the `mean()` of `treatment_outcome` minus the `mean()` of `control_outcome`.  Within both `mean()` functions set `na.rm` equals `TRUE`. You should gets a value of + 1.83.
```{r null-hypothesis-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r null-hypothesis-8-hint-1, eval = FALSE}
... |>
   summarise(mean_difference = mean(treatment_outcome, na.rm = TRUE) - 
                              mean(control_outcome, na.rm = TRUE))
```

### 

Instead of the NaN from the previous section where we run this command, this time we actually sees a value, but keep in mind that this value only exists under the null hypothesis, as we are manually giving values to the unknowns to calculate the results.

### Exercise 9

Now change the assignment number within `filter()` to 1 or 32, this should returns NaN as your result. 
```{r null-hypothesis-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r null-hypothesis-9-hint-1, eval = FALSE}
... |>
  filter(assignment == 1)
```

### 

For assignment 1 all five values goe to the treatment, and non goes to control, it doesn't make sense to subtract something that doesn't exist so r returns NA for us. The same thing goes for assignment 32 where all five values goe to the control. 

### Exercise 10

Now do the other assignments also have the same issue? Change the assignment number to any number between 2 and 31 inclusive to see if you get any NA's in your results. 
```{r null-hypothesis-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r null-hypothesis-10-hint-1, eval = FALSE}
... |>
  filter(assignment == ...)
```

### 

You shouldn't get any NA's here, and this is why the null hypothesis is so powerful because it allow us to calculate the possible outcomes of every different combination of treatments and controls. 



## All estimated treatment effects
### 

<!-- Do the same thing as previous section, but for all 32 possible assigments. (Note that two of them will drop out because they are everyone gets treatment or everyone gets control.) Results in 30 numbers. Makes a bar chart of those 30 numbers. -->

Let's apply the method we use to calculate the ETE in previous sections to all assignments and build a plot to show the distribution of our ETE and where our experimental observations should be placed in the distribution.

```{r}

# scale_fill_manual(values = c('grey50', 'red')) could be deleted or replace.

# consider theme(legend.position = "none") after labs?

set.seed(100)
all_est_p <- all_assignments |>
  mutate(Y_t = rep(c(13, 14, NA ,NA ,3), 32)) |> 
  mutate(Y_c = rep(c(NA, NA, 6, 12, NA), 32)) |>
  mutate(combine_outcome = coalesce(Y_t,Y_c)) |>
  mutate(treatment_outcome = if_else(treatment, combine_outcome, NA_real_)) |>
  mutate(control_outcome =   if_else(control,   combine_outcome, NA_real_)) |> 
  
  # treatment_outcome and control_outcome is after applying null hypoethsis
  
  group_by(assignment) |>
  summarise(mean_difference = mean(treatment_outcome, na.rm = TRUE) - 
                              mean(control_outcome, na.rm = TRUE)) |>
  drop_na() |>
  ggplot(aes(x = mean_difference, fill = mean_difference == 1)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.15,
                   color = "white")+
  
  # try to use the same thing over and over again to show how after_stat would work to turn into decimals.
  
    scale_fill_manual(values = c('grey50', 'red')) +
    scale_x_continuous(breaks = seq(-9, 9, 1), labels = -9:9)+
    scale_y_continuous(labels= scales::percent_format(accuracy = 1)) +
  theme(legend.position = "none")+
  labs(title = "Estimated Treatment Effect for all Possible Assignments",
       subtitle = "If the null hypothesis is true, an estimated treatment effect of 1 would not be surpring.",
       x = "Estimated Treatment Effect",
       y = "Probability",
       fill = "Experiment ETE")



all_est_p
  
```

### Exercise 1

Start a pipe with `all_assignments`. Use `mutate()` to create a variable `Y_t` which repeats `c(13, 14, NA ,NA ,3)` 32 times

```{r all-estimated-treatm-1, exercise = TRUE}

```


```{r all-estimated-treatm-1-hint-1, eval = FALSE}
... |>
   mutate(Y_t = rep(c(13, 14, NA ,NA ,3), 32)) 
```

### Exercise 2

Similarly, using `mutate()` create a variable `Y_c` which repeats `c(NA, NA, 6, 12, NA)` 32 times
```{r all-estimated-treatm-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-2-hint-1, eval = FALSE}
... |>
   mutate(Y_c = rep(c(NA, NA, 6, 12, NA), 32))
```

### Exercise 3

Next, use `mutate()` to create a new variable `combine_outcome` which is equal to `coalesce()`that takes on the two values `Y_t` and `Y_c`.
```{r all-estimated-treatm-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-3-hint-1, eval = FALSE}
... |>
  mutate(combine_outcome = coalesce(Y_t,Y_c))
```

### Exercise 4

Using `mutate()` create a variable `treatment_outcome` and set it equal to `if_else()` which has three arguments in order, `treatment`, then `combine_outcome` , then `NA_real_`. 
```{r all-estimated-treatm-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-4-hint-1, eval = FALSE}
... |>
   mutate(treatment_outcome = if_else(treatment, combine_outcome, NA_real_))
```

### 

`treatment_outcome` is basically the `t_outcome` in previous two sections, but this time since the `y_t` and `y_c` are identical we no longer need to specify which one when `if_else` returns true.

### Exercise 5

Use `mutate()` to create a variable `control_outcome` and set it equal to `if_else()` with the arguments `control`, `combine`,and `NA_real_`. 
```{r all-estimated-treatm-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-5-hint-1, eval = FALSE}
... |>
   mutate(control_outcome =   if_else(control,   combine_outcome, NA_real_))
```

### Exercise 6

Use `group_by()` to create a group based on `assignment`
```{r all-estimated-treatm-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-6-hint-1, eval = FALSE}
... |>
   group_by(assignment)
```

With `group_by` we are separating the data based on each assignment, and of the total 32 groups we have 32 different assignments.

### Exercise 7

Use `summarise()` to create an variable `mean_difference`, and set it equal to the `mean()` of `treatment_outcome` minus the `mean()` of `control_outcome`.  Within both `mean()` functions set `na.rm` equal to `TRUE`. 
```{r all-estimated-treatm-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-7-hint-1, eval = FALSE}
... |>
  summarise(mean_difference = mean(treatment_outcome, na.rm = TRUE) - 
                              mean(control_outcome, na.rm = TRUE))
```

### Exercise 8

Run `drop_na()` to drop the option for 5 treatments and 5 controls, as they all result in NA when calculating the mean.
```{r all-estimated-treatm-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-8-hint-1, eval = FALSE}
... |>
  drop_na()
```

### Exercise 9

Using `ggplot()` within use `aes()` set `x` equal to `mean_difference` and set `fill` equal to whether `mean_difference` is equal to 1. Then add the layer `geom_histogram()`.
```{r all-estimated-treatm-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-9-hint-1, eval = FALSE}
... |>
  ggplot(aes(x = mean_difference, fill = mean_difference == 1)) +
    geom_histogram()
```

### Exercise 10

Within `geom_histogram()`, use `aes()` to add aesthetic with `after_stat()` . Inside `aes()`, set `y` equals to `after_stat()` with the argument `count/sum(count)` to put percents on the y-axis.
```{r all-estimated-treatm-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-10-hint-1, eval = FALSE}
... +
  geom_histogram(aes(y = after_stat(count/sum(count))))
```

### Exercise 11

Set `binwidth` to .15 and `color` to "white" within `geom_histrogram()`.
```{r all-estimated-treatm-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-11-hint-1, eval = FALSE}
... +
  geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.15,
                   color = "white")
```

### Exercise 12

Use `scale_fill_manual` to change the fill to different colors, setting the `values` equal to `c('grey50', 'red')`.
```{r all-estimated-treatm-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-12-hint-1, eval = FALSE}
... +
  scale_fill_manual(values = c('grey50', 'red'))
```

### Exercise 13

Now use `scale_x_continuous()` so the x-axis has `breaks` to the sequence between -9 and 9 with a common difference of 1 using `seq()`. Set the `labels` for the breaks from -9 to 9.
```{r all-estimated-treatm-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-13-hint-1, eval = FALSE}
... +
  scale_x_continuous(breaks = seq(-9, 9, 1), labels = -9:9)
```

### Exercise 14

Now use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.
```{r all-estimated-treatm-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-14-hint-1, eval = FALSE}
... + 
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 15

Using `theme()` set `legend.position` equal to "none".
```{r all-estimated-treatm-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-15-hint-1, eval = FALSE}
... +
  theme(legend.position = "none")+
```

### 

This is because we don't want to show the fill legend as it doesn't really mean anything except distinguish the red line with other which the color already does by itself.



### Exercise 16

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels. 
```{r all-estimated-treatm-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r all-estimated-treatm-16-hint-1, eval = FALSE}
labs(title = "...",
     subtitle = "...",
     ...)
```

Reminder: Your plot should look similar to the the one below. 

```{r}
all_est_p
```

### 

Now what does this graph show? First by finding our experiment observation or the experiment assignment ETE we calculated in the first section, we know that the ETE for the experiment assignment is 1. 


## Full example

Real examples have way more than 5 units, there are trillions of possible assignments yet we can't calculate the estimated treatment effect under the null hypothesis for all of them. So, we need to use sampling. 

### 

<!-- Real examples have way more than 5 units. Two things happen. First, there are trillions of possible assignments, so we can't calculate the estimated treatment effect under the null hypothesis for all of them. So, we need to sample. Second, given this wealth of possibility, we purposely chose not to select "weird" assignments. Selected "balanced" treatment assignments, with approximately the same number of treated and control. -->

<!-- Use the whole trains data set. Use att_end as your variable. And then do the whole thing above. In first section, calculate the estimated treatment effect by hand, like: -->

<!-- ```{r} -->
<!-- trains |> group_by(treatment) |> summarize(mean(att_end)) -->
<!-- ``` -->

<!-- sample(c(TRUE, FALSE), size = 115, replace = TRUE), probbaly use map functions. -->
Let's build the permutation distribution for the `trains` dataset.

```{r}
set.seed(2)
S_obs <- 
  trains |> 
  select(treatment, att_end) |>
  mutate(treatment = case_when(
    treatment == "Treated" ~ TRUE,
    treatment == "Control" ~ FALSE)) |>
  mutate(control = ! treatment) |>
  relocate(control, .before = att_end) |>
  mutate(treatment_outcome = if_else(treatment, att_end, NA_real_)) |>
  mutate(control_outcome =   if_else(control,   att_end, NA_real_)) |>
  summarise(mean_difference = mean(treatment_outcome, na.rm = TRUE) - 
                              mean(control_outcome, na.rm = TRUE)) |>
  pull(mean_difference)


### Is there a way to not have this object created?
  

 perm_p <-
  tibble(ID = 1:5000) |>
  group_by(ID) |>
  mutate(treatment = map(ID, ~sample(c(TRUE, FALSE), size = 115, replace = TRUE))) |>
  mutate(comb_outcome = map(ID, ~c(trains$att_end))) |>
  unnest(c(treatment,comb_outcome)) |>
  mutate(control = ! treatment) |>
  relocate(control, .before = comb_outcome) |>
  mutate(treatment_outcome = if_else(treatment, comb_outcome, NA_real_)) |>
  mutate(control_outcome =   if_else(control,   comb_outcome, NA_real_)) |>
  summarise(mean_difference = mean(treatment_outcome, na.rm = TRUE) - 
                              mean(control_outcome, na.rm = TRUE)) |>
    ggplot(aes(x = mean_difference)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.05,
                   color = "white") +
    scale_y_continuous(labels= scales::percent_format(accuracy = 1))+
    annotate('segment', 
             x = S_obs, 
             xend = S_obs, 
             y = 0.015,
             yend = 0.002,
             size = 0.5, 
             arrow = arrow())+
    annotate('text', 
             x = S_obs, 
             y = 0.016, 
             size = 3.5, 
             label = 'Experiment Observation') +
   
  # Like we only use S_obs for annotate which is kinda useless.
   
    labs(title = "Permutation distribution of estimated treatment effect",
         subtitle = "Experiment ETE is unlikely to appear under null hypothesis",
         x = "Estimated Treatment Effect",
         y = "Probability")
    
  
perm_p
```

### Exercise 1

Before we start building our plot we need to first calculate the experiment result for the `trains` data set. Start by calling the `trains` dataset.

```{r full-example-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-1-hint-1, eval = FALSE}
trains
```

### 

The trains data set has 14 columns and 115 rows. The columns that we care about are `treatment` and `att_end`.

### Exercise 2

Start a pipe with `trains`, selecting the `treatment` and `att_end` column from the data-set.
```{r full-example-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-2-hint-1, eval = FALSE}
trains |>
  select(... , ...)
```

### 

Note that the vector for `treatment` is `factor`, and the vector for `att_end` is double. To follow the steps we did in exercises we need to turn the factor vectors for `treatment` to `logical` vectors like `TRUE` and `FALSE`.

### Exercise 3

Use `mutate()` to overwrite `treatment` to `TRUE` if `treatment` is equal to "Treated", and to `FALSE` if `treatment` is equal to `Control`. Use `case_when()`.
```{r full-example-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-3-hint-1, eval = FALSE}
... |>
 mutate(treatment = case_when(
    treatment == "Treated" ~ TRUE,
    treatment == "Control" ~ FALSE))
```

### 

`mutate()` can add new variables while reversing existing ones since new variables can overwrites existing ones if they have the same name.

### Exercise 4

Use `mutate()` to create a variable `control` and set it equal to the opposite of `treatment` using `!`.
```{r full-example-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-4-hint-1, eval = FALSE}
... |>
  mutate(control = ! treatment)
```

### Exercise 5

Use `relocate()` which has two arguments, the first being `control`, then set `.befire` equal to `att_end`.
```{r full-example-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-5-hint-1, eval = FALSE}
... |>
  relocate(control, .before = att_end)
```

### 

`relocate()` can change columns position. We can also run `select(treatment,control, att_end)` which moves multiple blocks of columns at once.

### Exercise 6

Use `mutate()` to create a variable `treatment_outcome` and set it equal to `if_else()` which has three arguments in order, `treatment`, `att_end` , then `NA_real_`.
```{r full-example-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-6-hint-1, eval = FALSE}
... |>
  mutate(treatment_outcome = if_else(treatment, att_end, NA_real_))
```

### 

The `att_end` here is the same as combine outcome, because under null hypothesis the potential outcomes of treatment and control is identical. 

### Exercise 7

Use `mutate()` create another variable `control_outcome` and set it equal to `if_else()` with the arguments, `control`, `att_end`,and `NA_real_`. 
```{r full-example-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-7-hint-1, eval = FALSE}
... |>
  mutate(control_outcome =   if_else(control,   att_end, NA_real_))
```

### Exercise 8

Use `summarise()` to create an variable `mean_difference`, and set it equal to the `mean()` of `treatment_outcome` minus the `mean()` of `control_outcome`.  Within both `mean()` functions set `na.rm` equals `TRUE`.  The estimated treatment effect for the experiment observation should be approximately +1.55.
```{r full-example-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-8-hint-1, eval = FALSE}
... |>
  summarise(mean_difference = mean(treatment_outcome, na.rm = TRUE) - 
                              mean(control_outcome, na.rm = TRUE))
```

### 

Since we are only calculating for the experiment estimated treatment effect, we don't need to use `group_by()` before `summarise()`, because ultimately we only want one value to be our experiment observation.

### Exercise 9

Turn the tibble we just created into a vector by running `mean_difference` inside `pull()`.
```{r full-example-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-9-hint-1, eval = FALSE}
... |>
   pull(mean_difference)
```

### 

We need to turn the tibble into a vector because later we will need to apply this vector into another data.frame, yet we can't apply a data frame into another data frame.

### Exercise 10

Create a new object `S_obs` and assign everything above to this object.
```{r full-example-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-10-hint-1, eval = FALSE}
S_obs <-
  ...
```

### 

Let's start building the graph now.

### Exercise 11

Using `tibble()` create a variable ID, and set it equal to `1:5000`.
```{r full-example-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-11-hint-1, eval = FALSE}
tibble(ID = 1:5000)
```

### 

The ID also represents our assignment number. Since there are in total of 2^115 possible assignments and we can't calculate all of them, we can randomly select 5000 from these assignments and calculate the estimated effect for them.  


### Exercise 12

Use `group_by()` to create 5000 groups based on ID.
```{r full-example-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-12-hint-1, eval = FALSE}
... |>
  group_by(ID)
```

### Exercise 13

Use `mutate()` to create a new variable `treatment` equal to `map()` which has two arguments, first being `ID`, secondly the formula of `sample()` which is `c(TRUE, FALSE)`, each time with `size` of 115, and set `replace` equal to `TRUE`. Use `~` for formula. 
```{r full-example-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-13-hint-1, eval = FALSE}
... |>
  mutate(treatment = map(ID, ~sample(c(TRUE, FALSE), size = 115, replace = TRUE)))
```

### 

The new column `treatment` is a column with 5000 rows of list-columns each with 115 values which are all logical vectors. What this step does is for each of `ID`, it samples a combination of treatment and control from the total of 2^115 combinations. 

### Exercise 14

Use `mutate()` to create a new variable `comb_outcome` which is equal to `map()` including two arguments, `ID`, and formula `c(trains$att_end)`. 
```{r full-example-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-14-hint-1, eval = FALSE}
... |>
  mutate(comb_outcome = map(ID, ~c(trains$att_end)))
```

### 

`comb_outcome` is a column with 5000 rows of list columns each with 115 values which are all double vectors. The 115 values are the `att_end` from the `trains` data set. We can't import the entire data-set within the tibble, and that's why we use the `$` operator, which picks specific columns and turn them into vectors, similar to the `pull()` function.

### Exercise 15

Use `unnest()` which includes the `treatment`, and `comb_outcome` columns inside `c()`
```{r full-example-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-15-hint-1, eval = FALSE}
... |>
  unnest(c(ID, treatment,comb_outcome))
```

### 

This step unnests the two columns which each have a row made of a list-column. Now for a single ID like 1 it has a total of 115 rows of `treatment`, and `att_end`.  

### Exercise 16

Use `mutate()` to create a variable `control` and set it equal to the opposite of `treatment` using an `!`.
```{r full-example-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-16-hint-1, eval = FALSE}
... |>
  mutate(control = ! treatment) 
```

### Exercise 17

Use `relocate()` which has two arguments, `control` and set `.befire` equal to `att_end`.
```{r full-example-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-17-hint-1, eval = FALSE}
relocate(control, .before = att_end)
```

### Exercise 18

Use `mutate()` to create a variable `treatment_outcome` and set it equal to `if_else()` which has three arguments in order, `treatment`, `att_end` , then `NA_real_`.
```{r full-example-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-18-hint-1, eval = FALSE}
... |>
  mutate(treatment_outcome = if_else(treatment, att_end, NA_real_))
```

### Exercise 19

Use `mutate()` create a variable `control_outcome` and set it equal to `if_else()` with the arguments `control`, `att_end`, and `NA_real_`. 

```{r full-example-19, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-19-hint-1, eval = FALSE}
... |>
  mutate(control_outcome =   if_else(control,   att_end, NA_real_))
```

### Exercise 20

Use `summarise()` to create an variable `mean_difference`, and set it equal to the `mean()` of `treatment_outcome` minus the `mean()` of `control_outcome`.  Within both `mean()` functions set `na.rm` equals `TRUE`. 

```{r full-example-20, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-20-hint-1, eval = FALSE}
... |>
  summarise(mean_difference = mean(treatment_outcome, na.rm = TRUE) - 
                              mean(control_outcome, na.rm = TRUE))
```

### 

If the three previous exercises were repeated again, you would have a tibble that has two columns and 5000 rows, note how the repetition of each `ID` number is gone when we run our `summarise()` command. 

### Exercise 21

Use `ggplot()` and `geom_histogram()` to graph out the distribution, setting x equal to "mean_difference" within `aes()`.
```{r full-example-21, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-21-hint-1, eval = FALSE}
... |>
  ggplot(aes(x = mean_difference)) +
   geom_histogram()
```

### Exercise 22

Within `geom_histogram()`, use `aes()` . Inside `aes()`, set `y` equal to `after_stat()` with the argument `count/sum(count)` to put percents on the y-axis.

```{r full-example-22, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-22-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = after_stat(...))) 
```

### Exercise 23

Also set `binwidth` to .05 and `color` to "white" within `geom_histrogram()`.

```{r full-example-23, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-23-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = .05, 
                   color = "white") 
```

### Exercise 24

Use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` equal to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.
```{r full-example-24, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-24-hint-1, eval = FALSE}
... + 
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 25

Use `annotate()`, which has 7 small arguments, first is 'segment', secondly set `x` equal to `S_obs`, next set `xend` also equal to `S_obs`,set `y` equal to 0.015, set `yend` equal to 0.002, set `size equal to 0.5`, and finally set `arrow` equal to `arrow()`.
```{r full-example-25, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-25-hint-1, eval = FALSE}
...|>
  annotate('segment', 
             x = S_obs, 
             xend = S_obs, 
             y = 0.015,
             yend = 0.002,
             size = 0.5, 
             arrow = arrow())
```

### 

'segment' is the geom arguments within `annotate()`, `x`,`xend`,`y`, and `yend` are all positioning aesthetics, this would returns an arrow pointing downward toward x equal to 1.55.

### Exercise 26

Use `annotate()` again to add labels, this time with the 5 arguments, 'text', `x` equal to `S_obs`, `y` equal to 0.016, `size` equal to 3.5, and `label` equal to 'Experiment Observation'.
```{r full-example-26, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r full-example-26-hint-1, eval = FALSE}
... +
  annotate('text', 
             x = S_obs, 
             y = 0.016, 
             size = 3.5, 
             label = 'Experiment Observation')
```

### 

Similar to the last step we are adding another annotation to the graph. Since we want the arrows to pointing at the experiment ETE, we can plug in the `S_obs` which we calculated before to indicate where the experiment observation is. 

### Exercise 27

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.
```{r full-example-27, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: Your graph should looks like one below.

```{r}
perm_p
```

### 

What does this graph means? Is our experiment observation "surprising"? Yes, looking at the arrows, the chance for the value 1.55 to occur is less than 0.5%, which means that the chance is very unlikely for our experiment observation to occur. In other word, our null hypothesis is not true, which means that the treatment given in the `trains` data-set is very effective. 

## Summary
### 

Once again, a *permutation test* starts with the assumption that the true average treatment effect is zero, and then calculates how "surprising" our estimated average treatment effect is, given that assumption. If the surprise is big enough, we conclude that the average treatment effect is not zero.

Here are the steps for a permutation test:

1. Calculate the estimated average treatment effect for the actual data.   
2. Assume the null hypothesis true: the treatment effect is zero for all units.      
3. Calculate the estimated treatment effect for a large number of possible assignments.    
4. Construct the permutation distribution.  
5. Determine if the experiment ETE is "unlikely" to appear under null hypothesis.   
6. If the experiment result is unlikely, conclude that the null hypothesis is false.

<!-- DK: Drop this elsewhere: -->

Consider [this video](https://www.youtube.com/watch?v=GmvpsJHGCxQ), which gives a great visual example through cards and shuffling.

###
You made it. Congrats on finishing this tutorial!

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
