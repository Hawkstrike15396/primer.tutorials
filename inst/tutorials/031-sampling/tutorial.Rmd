---
title: Sampling
author: David Kane and Gia Khang
tutorial:
  id: sampling
output:
  learnr::tutorial:
    progressive: yes
    'allow_skip:': yes
runtime: shiny_prerendered
description: 'Chapter 3 Tutorial: Sampling'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
library(gt)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 600, 
        tutorial.storage = "local") 

# Key Data

set.seed(10)
urn <- tibble(color = c(rep("red", 400), rep("white", 600))) |>
  sample_frac() |> 
  mutate(bead_ID = 1:1000) 

virtual_samples <- tibble(trial_ID = 1:1000) |> 
  mutate(shovel = map(trial_ID, ~ sample_n(urn, size = 50))) |> 
  mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) |> 
  mutate(numb_beads = map_int(shovel, ~ length(.$color))) |> 
  mutate(prop_red = numb_red / numb_beads)

shovels_100 <- expand_grid(trial_ID = 1:100, shovel_size = 1:100) |> 
  mutate(shovel = map(shovel_size, ~ slice_sample(urn, n = .))) |> 
  mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) |> 
  mutate(prop_red = numb_red / shovel_size) |> 
  group_by(shovel_size) |> 
  summarize(st_dev_p_hat = sd(prop_red)) 
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

<!-- This tutorial sticks! -->

<!-- Khang: Please fix everything! -->

<!-- Delete everything that you can't defend. -->

<!-- Add test chunks everywhere.  -->

<!-- Section about real sampling? no! -->

<!-- Add courage and temperance sections. -->

<!-- Make the Cardinal Virtues section a simpler version of the ones we use in Chapters 4 through 10. No Github for example. Use the tutorial_tempate.Rmd as much as you think wise. -->

## Introduction
### 

This tutorial covers [Chapter 3: Sampling](https://ppbds.github.io/primer/sampling.html) of [*Preceptor’s Primer for Bayesian Data Science: Using the Cardinal Virtues for Inference*](https://ppbds.github.io/primer/) by [David Kane](https://davidkane.info/). In this chapter, we will learn about *sampling*, the beginning of our journey toward inference. When we sample, we take some *units* from a population. With the data collected via sampling, we will create statistical models with just one unknown parameter. With such models, we can make inferences in order to answer questions. Along that journey, we learn to use the **Cardinal Virtues** to guide our actions. 


## Virtual Sampling
### 

<!-- Start by introducing related terminologies, at the end ask students to write a small paragraph to connect those terminologies together to build up an intuitive approach to the problem -->
<!-- GK: Rephrase -->
In this section, we mimic physical sampling with virtual sampling, using a computer. In a real sampling activity, we would perform a tactile sampling activity. In this we use a physical urn of beads and a physical shovel which is done by hand so that we could develop our intuition about the ideas behind sampling. 

### 

We begin this chapter with a specific problem: 
> Given an urn consists of 1,000 identically sized red and white beads in the urn, mixed well together. What proportion, $p$, of this urn's beads are red?

In this section, we will create the following plot to answer this question.

```{r}
plot_vs <- virtual_samples |> 
  ggplot(aes(x = prop_red)) +
    geom_histogram(binwidth = 0.01, 
                   boundary = 0.4, 
                   color = "white") +
    labs(x = expression(hat(p)), 
         y = "Count",
         title = "Distribution of 1,000 proportions red") 

plot_vs
```

### Exercise 1

Define the **Population** in this problem?

```{r virtual-sampling-1}
question_text(NULL,
	message = "In our sampling activities, the population is the collection 1,000 identically sized red and white beads in the urn.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

<!-- Add knowledge drop about Population parameter -->


### Exercise 2

In your own word, define a **Census** in this problem? 

```{r virtual-sampling-2}
question_text(NULL,
	message = "A **Census** is an exhaustive enumeration or counting of all units in the population in order to compute the population parameter's value exactly.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 3

In your own word, explain how **Census** can help us answer our question?

```{r virtual-sampling-3}
question_text(NULL,
	message = "We can answer our question by counting the number of red beads out of the total 1,000 beads in the urn and then computing the proportion of red beads.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

Assuming zero error when counting, this method will return the **exact** portion of red beads in the urn. However, it can be quite expensive in terns of time, energy and money when the population is large or even impossible. 

### Exercise 4

In two sentences, describe the act of **Sampling** and what is the **Sample** in this problem?


```{r virtual-sampling-4}
question_text(NULL,
	message = "Sampling is the act of collecting a sample from the population. In our sampling activity, we use the shovels to collect a certain number of beads from the urn.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 5

In your own words, define what is necessary for a sample to be **representative**?

```{r virtual-sampling-5}
question_text(NULL,
	message = "Place correct answer here.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

<!-- Add knowledge drop about what can't we do if the sample is not representative  -->

### Exercise 6

In your own words, define what is necessary for a sample to be **generalizable**? 

```{r virtual-sampling-6}
question_text(NULL,
	message = "Place correct answer here.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

<!-- Add knowledge drop about what can't we do if the sample is not generalizable  -->


### Exercise 7

In your own words, define **biased sampling**.
```{r virtual-sampling-7}
question_text(NULL,
	message = "Place correct answer here.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 8

Provide one example for this problem where the sampling could be **biased**.

```{r virtual-sampling-8}
question_text(NULL,
	message = "Had the red beads been much smaller than the white beads, and therefore more prone to falling out of the shovel, our sample would have been biased.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

In our sampling activities, since we mixed all 1,000 beads prior to each group’s sampling and since each of the equally sized beads had an equal chance of being sampled, our samples were unbiased.

### Exercise 9

In your own word, define when a sampling procedure is *random* in this specific problem. 


```{r virtual-sampling-9}
question_text(NULL,
	message = "Sampling procedure is random if we sample randomly from the population in an unbiased fashion. In our sampling activities, this would correspond to sufficiently mixing the urn before each use of the shovel.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

<!-- The knowledge drop in each exercise can be combined to construct the paragraph.  -->

### Exercise 10

Write a few sentences to summarize our approach to answer the question, use the knowledge drop in each exercise to guide your answer. 

```{r virtual-sampling-10}
question_text(NULL,
	message = "Place correct answer here.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 11

Create a `urn` variable on the second line that is set to a `tibble()`. Within the `tibble()` set `color` to the combination of `rep("red", 400)` and `rep("white", 600)`.

```{r virtual-sampling-11, exercise = TRUE}
set.seed(10)

```

```{r virtual-sampling-11-hint-1, eval = FALSE}
set.seed(10)
urn <- tibble(... = c(rep("...", ...), 
                        rep("...", ...)))
```

```{r virtual-sampling-11-test, include = FALSE}
set.seed(10)
urn <- tibble(color = c(rep("red", 400), 
                        rep("white", 600)))
```

### 

`set.seed()` ensures that the beads in our virtual urn are always in the same order. This ensures that the figures in the book match their written descriptions. We want 40% of the beads to be red. The `rep()` function will repeat the first argument a number of times specified by the second argument. We then combine our 400 red beads and 600 white beads using `c()`.

### Exercise 12

Within the `urn` variable start a pipe and set it to `sample_frac()`.

```{r virtual-sampling-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r virtual-sampling-12-hint-1, eval = FALSE}
urn <- ... |>
          sample_frac()
```

```{r virtual-sampling-12-test, include = FALSE}
urn <- tibble(color = c(rep("red", 400), 
                        rep("white", 600))) |> 
  sample_frac()
```

### 

`sample_frac()` keeps all the rows in the tibble but rearranges their order. We don't need to do this. A virtual urn does not care about the order of the beads. But we find it aesthetically pleasing to mix them up.

### Exercise 13

Finish the pipe with `mutate()` and set `bead_ID` to 1 through 1000.

```{r virtual-sampling-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r virtual-sampling-13-hint-1, eval = FALSE}
urn <- ... |>
          mutate(... = 1:1000)
```

```{r virtual-sampling-13-test, include = FALSE}
urn <- tibble(color = c(rep("red", 400), 
                        rep("white", 600))) |> 
  sample_frac() |> 
  mutate(bead_ID = 1:1000)
```

### 

The first variable `bead_ID` is used as an identification variable. None of the beads in the actual urn are marked with numbers. The second variable `color` indicates whether a particular virtual bead is red or white.

### Exercise 14

To simulate the process of real-world sampling, let’s take a sample of 50 beads from our virtual urn. To do so, create a `tibble()` that has one variable `trial_ID` that takes on the values 1 to 1000.

```{r virtual-sampling-14, exercise = TRUE}

```

```{r virtual-sampling-14-hint-1, eval = FALSE}
tibble(trial_ID = ...)
```

```{r virtual-sampling-14-hint-2, eval = FALSE}
Use the : operator to create a range of integers.
```

```{r virtual-sampling-14-test, include = FALSE}
tibble(trial_ID = 1:1000)
```

### Exercise 15

<!-- GK: Should be separate into smaller questions -->

Now pipe your results to the function `mutate()` to create the variable `shovel`, which is set to the function `map()`. The first argument to `map()` should be `trial_ID`. The second argument should use `slice_sample()`. Within `slice_sample()`, the first argument should be `urn` (the data we want to sample from), and then set `n` equal to our sample size (we want a sample size of 50). 

```{r virtual-sampling-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r virtual-sampling-15-hint-1, eval = FALSE}
... |> 
  mutate(shovel = map(..., ~ ...))
```

```{r virtual-sampling-15-hint-2, eval = FALSE}
... |> 
  mutate(shovel = map(..., ~slice_sample(urn, n = ...)))
```

```{r virtual-sampling-15-test, include = FALSE}
tibble(trial_ID = 1:1000) |> 
  mutate(shovel = map(trial_ID, ~ slice_sample(urn, n = 50)))
```

### 

The advantage of modern technology is that we can use virtual simulation as many times as we choose, so we have no restrictions on resources. No longer are the days where we have to recruit our friends to tirelessly sample from the physical urn.

### Exercise 16

Continue your pipe with `mutate()` to create the variable `numb_red`. Set `numb_red` to the function `map_int()`. The first argument to `map_int()` should be `shovel`. The second argument should take the `sum()` of where `.$color` is equal to red.

```{r virtual-sampling-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r virtual-sampling-16-hint-1, eval = FALSE}
... |> 
  mutate(... = map_int(..., ~...))
```

```{r virtual-sampling-16-hint-2, eval = FALSE}
... |> 
  mutate(... = map_int(..., ~ sum(.$color == "red")))
```

```{r virtual-sampling-16-test, include = FALSE}
tibble(trial_ID = 1:1000) |> 
  mutate(shovel = map(trial_ID, ~ slice_sample(urn, n = 50))) |> 
  mutate(numb_red = map_int(shovel, ~sum(.$color == "red")))
```

### 

R evaluates if `color == red`, and treats `TRUE` values like the number `1` and `FALSE` values like the number `0`. So summing the number of `TRUE`s and `FALSE`s is equivalent to summing `1`’s and `0`’s. In the end, this operation counts the number of beads where `color` equals “red”.

### Exercise 17

Use `mutate()` one last time to create the variable `prop_red`. Set `prop_red` to `numb_red` divided by the sample size (in this exercise we are using a set sample size of 50).

```{r virtual-sampling-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r virtual-sampling-17-hint-1, eval = FALSE}
... |> 
   mutate(prop_red = ... / ...)
```

```{r virtual-sampling-17-test, include = FALSE}
tibble(trial_ID = 1:1000) |> 
  mutate(shovel = map(trial_ID, ~ slice_sample(urn, n = 50))) |> 
  mutate(numb_red = map_int(shovel, ~sum(.$color == "red"))) |> 
  mutate(prop_red = numb_red / 50)
```

### 

`prop_red` estimate's our proportion of red beads in the urn.

### Exercise 18

Assign your code from above to an object named `virtual_samples`.

```{r virtual-sampling-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r virtual-sampling-18-hint-1, eval = FALSE}
Use the assignment operator <-  to do so.
```

```{r virtual-sampling-18-test, include = FALSE}
virtual_samples <- tibble(trial_ID = 1:1000) |> 
  mutate(shovel = map(trial_ID, ~ slice_sample(urn, n = 50))) |> 
  mutate(numb_red = map_int(shovel, ~sum(.$color == "red"))) |> 
  mutate(prop_red = numb_red / 50)
```

### Exercise 19

Now start a pipe with `virtual_samples`. Use `ggplot()` to map `prop_red` to the x-axis.

```{r virtual-sampling-19, exercise = TRUE}

```

```{r virtual-sampling-19-hint-1, eval = FALSE}
virtual_samples |> 
  ggplot(aes(...))
```

```{r virtual-sampling-19-test, include = FALSE}
virtual_samples |> 
  ggplot(aes(x = prop_red))
```

### Exercise 20

Add the layer `geom_histogram()` to create a histogram of our data.

```{r virtual-sampling-20, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r virtual-sampling-20-hint-1, eval = FALSE}
... +
  geom_histogram()
```

```{r virtual-sampling-20-test, include = FALSE}
virtual_samples |> 
  ggplot(aes(x = prop_red)) + 
  geom_histogram()
```

### Exercise 21

Within `geom_histrogram()` set `binwidth` to .01, `boundary` to .4, and `color` to "white".

```{r virtual-sampling-21, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r virtual-sampling-21-hint-1, eval = FALSE}
... +
  geom_histrogram(binwidth = ..., boundary = ..., color = ...)
```

```{r virtual-sampling-21-test, include = FALSE}
virtual_samples |> 
ggplot(aes(x = prop_red)) +
  geom_histogram(binwidth = 0.01, 
                 boundary = 0.4, 
                 color = "white")
```

### 

Recall that `p` is equal to the proportion of beads which are red in each sample.

### Exercise 22

To finish, use `labs()` to give your graph the appropriate title and axis labels. See **hint** for guidance to create the symbol $\hat{p}$.

```{r virtual-sampling-22, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: This is what your plot should look like. 

```{r}
plot_vs
```

```{r virtual-sampling-22-hint-1, eval = FALSE}
Within labs(), set x to expression(hat(p))
```

```{r virtual-sampling-22-test, include = FALSE}
virtual_samples |> 
ggplot(aes(x = prop_red)) +
  geom_histogram(binwidth = 0.01, 
                 boundary = 0.4, 
                 color = "white") +
  labs(x = expression(hat(rho)),
       y = "Count",
       title = "Distribution of 1,000 proportions red") 
```

### 

This visualization allows us to see how our results differed between our tactile and virtual urn results. As we can see, there is some variation between our results. This is not a cause for concern, as there is always expected sampling variation between results.


## Standard error of different shovel sizes
### 

<!-- MT: add questions about the definitions/important concepts of standard error -->

Standard errors (SE) quantify the effect of sampling variation on our estimates. In other words, they quantify how much we can expect the calculated proportions of a shovel’s beads that are red to vary from one sample to another sample to another sample, and so on. As a general rule, as sample size increases, the standard error decreases.

### 

In this section, we will create the following plot that displays different standard deviations of red bead proportions for 100 different shovel sizes.

```{r}
shovel_p <- shovels_100 |>
 ggplot(aes(x = shovel_size, y = st_dev_p_hat)) +
 geom_point() +
 labs(title = "Sampling Variation",
      subtitle = "Larger samples have less variation",
      x = "Shovel size",
      y = "Standard deviation of the proportion red")

shovel_p
```

### Exercise 1

In your own word, define *Standard error*.

```{r standard-error-of-different-sh-1}
question_text(NULL,
	message = "The standard error is the standard deviation of a sample statistic (aka point estimate), such as the proportion. For example, the standard error of the mean refers to the standard deviation of the distribution of sample means taken from a population.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 2

<!-- GK: Need paraphrase, does not understand -->
First, let's use `expand_grid()` to create the foundation of our tibble. Our first column in `expand_grid()` should be called `trial_ID`, and it should be the range of integers between 1 and 1,000. The second column should be called `shovel_size`, and should be the range of integers between 1 and 100.

```{r standard-error-of-different-sh-2, exercise = TRUE}

```

```{r standard-error-of-different-sh-2-hint-1, eval = FALSE}
expand_grid(trial_ID = ..., shovel_size = ...)
```

```{r standard-error-of-different-sh-2-hint-2, eval = FALSE}
Use the : operator to create a range of integers. 
```

```{r standard-error-of-different-sh-2-test, include = FALSE}
expand_grid(trial_ID = c(1:1000), shovel_size = c(1:100))
```

### 

### Exercise 3

Continue the pipe with `mutate()`, creating a new column called `shovel`. Set `shovel` equal to a `map()` function, passing in `shovel_size` as the first argument, and the `slice_sample()` function as the second argument. Within `slice_sample()`, the first argument should be `urn` (the data we want to sample from), and then set `n` equal to `.` (we want to pass in the `shovel_size` using `map()`).

```{r standard-error-of-different-sh-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r standard-error-of-different-sh-3-hint-1, eval = FALSE}
... |>
  mutate(shovel = map(..., ~ ... ))
```

```{r standard-error-of-different-sh-3-hint-2, eval = FALSE}
... |>
  mutate(shovel = map(... , ~ slice_sample(..., n = ...)))
```

```{r standard-error-of-different-sh-3-test, include = FALSE}
expand_grid(trial_ID = c(1:1000), shovel_size = c(1:100)) |> 
  mutate(shovel = map(shovel_size, ~ slice_sample(urn, n = .)))
```

### 

### Exercise 4

Continue your pipe with `mutate()` to create the variable `numb_red`, which will tells us the number of red beads present. Set `numb_red` to the function `map_int()`. The first argument to `map_int()` should be `shovel`. The second argument should take the `sum()` of where the column `color` of `shovel` is equal to red.

```{r standard-error-of-different-sh-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r standard-error-of-different-sh-4-hint-1, eval = FALSE}
... |> 
  mutate(... = map_int(..., ~ ...))
```

```{r standard-error-of-different-sh-4-hint-2, eval = FALSE}
... |> 
  mutate(... = map_int(..., ~ sum(.$color == "red")))
```

```{r standard-error-of-different-sh-4-test, include = FALSE}
expand_grid(trial_ID = c(1:1000), shovel_size = c(1:100)) |> 
  mutate(shovel = map(shovel_size, ~ slice_sample(urn, n = .))) |> 
  mutate(numb_red = map_int(shovel, ~ sum(.$color == "red")))
```

### Exercise 5

Continue your pipe from above, using `mutate()` to create one final column called `prop_red` which represents the proportion of red beads in a sample. Set `prop_red` to `numb_red` divided by the `shovel_size` column. 

```{r standard-error-of-different-sh-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r standard-error-of-different-sh-5-hint-1, eval = FALSE}
... |>
  mutate(prop_red = ... / ...)
```

```{r standard-error-of-different-sh-5-test, include = FALSE}
expand_grid(trial_ID = c(1:1000), shovel_size = c(1:100)) |> 
  mutate(shovel = map(shovel_size, ~ slice_sample(urn, n = .))) |> 
  mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) |> 
  mutate(prop_red = numb_red / shovel_size)
```

### Exercise 6

Great. Continue your pipe and use the `group_by()` function to group our tibble by `shovel_size`. 

```{r standard-error-of-different-sh-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r standard-error-of-different-sh-6-hint-1, eval = FALSE}
... |>
  group_by(...)
```

```{r standard-error-of-different-sh-6-test, include = FALSE}
expand_grid(trial_ID = c(1:1000), shovel_size = c(1:100)) |> 
  mutate(shovel = map(shovel_size, ~ slice_sample(urn, n = .))) |> 
  mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) |> 
  mutate(prop_red = numb_red / shovel_size) |> 
  group_by(shovel_size)
```

### Exercise 7

Continue your pipe one last time, and use `summarize()` to create a new column named `st_dev_p_hat` which is equal to the standard deviation of `prop_red`. (`sd()` calculates standard deviation).
 

```{r standard-error-of-different-sh-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r standard-error-of-different-sh-7-hint-1, eval = FALSE}
... |> 
  summarize(st_dev_p_hat = sd(...))
```

```{r standard-error-of-different-sh-7-test, include = FALSE}
expand_grid(trial_ID = c(1:1000), shovel_size = c(1:100)) |> 
  mutate(shovel = map(shovel_size, ~ slice_sample(urn, n = .))) |> 
  mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) |> 
  mutate(prop_red = numb_red / shovel_size) |> 
  group_by(shovel_size) |> 
  summarize(st_dev_p_hat = sd(prop_red))
```

### Exercise 8

Assign your code from above to an object named `shovels_100`.

```{r standard-error-of-different-sh-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r standard-error-of-different-sh-8-hint-1, eval = FALSE}
Use the assignment operator <-  to do so.
```

```{r standard-error-of-different-sh-8-test, include = FALSE}
shovels_100 <- expand_grid(trial_ID = c(1:1000), shovel_size = c(1:100)) |> 
  mutate(shovel = map(shovel_size, ~ slice_sample(urn, n = .))) |> 
  mutate(numb_red = map_int(shovel, ~ sum(.$color == "red"))) |> 
  mutate(prop_red = numb_red / shovel_size) |> 
  group_by(shovel_size) |> 
  summarize(st_dev_p_hat = sd(prop_red))
```

### Exercise 9

Start a new pipe from `shovels_100`. Use `ggplot()`to map `shovel_size` to the x-axis and `st_dev_p_hat` to the y axis. Also, add the layer `geom_point()` to create a scatterplot.

```{r standard-error-of-different-sh-9, exercise = TRUE}

```

```{r standard-error-of-different-sh-9-hint-1, eval = FALSE}
shovels_100 |> 
  ggplot(aes(x = ..., y = ...)) + 
  geom_point()
```

```{r standard-error-of-different-sh-9-test, include = FALSE}
shovels_100 |> 
  ggplot(aes(x = shovel_size, y = st_dev_p_hat)) + 
  geom_point()
```

### Exercise 10

Now use `labs()` to label the x-axis "Shovel size" and the y-axis 
"Standard deviation of the proportion red". You should also provide a title and subtitle.

```{r standard-error-of-different-sh-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: This is what your plot should look like.

```{r}
shovel_p
```

```{r standard-error-of-different-sh-10-hint-1, eval = FALSE}
... +
   labs(title = "Sampling Variation",
      subtitle = "Larger samples have less variation",
      x = "Shovel size",
      y = "Standard deviation of the proportion red")
```

```{r standard-error-of-different-sh-10-test, include = FALSE}
shovels_100 |> 
  ggplot(aes(x = shovel_size, y = st_dev_p_hat)) + 
  geom_point() + 
  labs(title = "Sampling Variation",
      subtitle = "Larger samples have less variation",
      x = "Shovel size",
      y = "Standard deviation of the proportion red")
```

### 

### Exercise 11

In one sentence, explain what you learn from the graph.

```{r standard-error-of-different-sh-11}
question_text(NULL,
	message = "The standard error of an estimate decreases at the rate of the square root of the population size.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### 

## Wisdom
### 

*All we can know is that we know nothing. And that’s the height of human wisdom.* - Leo Tolstoy

We have an urn with 1,000 identically sized red and white beads. We do not know the breakdown number of beads between red and white. 

> *We are interested in the number of white and red beads which will come out of the urn in the future.*

### 

We decide to make a guess by drawing a sample of 50 beads from the urn. It turns out that 17 of them were red. 

> *What proportion of beads in the urn are red?*

### Exercise 1

In your own words, describe the key components of Wisdom when working on a data science problem.

```{r wisdom-1}
question_text(NULL,
	message = "Wisdom requires the creation of a Preceptor Table, an examination of our data, and a determination, using the concept of validity, as to whether or not we can (reasonably!) assume that the two come from the same population.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

<!-- XX: You have the opportunity, in this and the next few questions, to drop a lot of knowledge about the data and the overall topic. Do so! But, remember, students won't read more than 2 or so sentences in a knowledge drop. -->

<!-- Not only are you discussing the data, but you are also discussing potential problems with the data, problems which will be more fully fleshed out in the Justice section. You want to pick 5 to 10 interesting facts about the data. (You may need to go to the original source, not simply relying on the chapter.) 

You won't be drawing any conclusions or pointing out any problems. That discussion is saved until Justice and the specific questions about stability and representativeness. You are, hwoever, providing the details which you and the students can then use later. -->

The urn is basically a container where we put all the beads in. We will be using the two terms "urn" and "population" interchangeably cause they all mean the same.

### Exercise 2

Define a Preceptor Table.

```{r wisdom-2}
question_text(NULL,
	message = "A Preceptor Table is the smallest possible table of data with rows and columns such that, if there is no missing data, we can easily calculate the quantities of interest.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

To answer the question we have, we need a table that contains the color of every beads in the urn. With that information, we can easily compute the total number of red beads, divided by the total beads to get the proportion. 

### Exercise 3

Describe the key components of Preceptor Tables in general, without worrying about this specific problem. Use words like "units," "outcomes," and "covariates."

```{r wisdom-3}
question_text(NULL,
	message = "The rows of the Preceptor Table are the units. The outcome is at least one of the columns. If the problem is causal, there will be at least two (potential) outcome columns. The other columns are covariates. If the problem is causal, at least one of the covariates will be a treatment.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 4

What are the units for this problem?

```{r wisdom-4}
question_text(NULL,
	message = "The units, are which the outcome is measured on, are the individual beads in the urn.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 5

What is/are the outcome/outcomes for this problem?

```{r wisdom-5}
question_text(NULL,
	message = "The outcome is the color for each individual bead in the urn. There are only 2 possible values for the outcome, which is red or white.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 


### Exercise 6

<!-- XX. You will probably need to make this question much more specific. In other words, you want the student to list some of the covariates that are available for him to consider. We are not just looking for the select few covariates which will end up in the model. Maybe some EDA needs to come first? -->

<!-- This is a lousy question! Which meaning of covariates do you intend? -->

What are some covariates which you think might be useful for this problem?

```{r wisdom-6}
question_text(NULL,
	message = "Covariates is the general term for all the variables which are not the **outcome**. There is no covariate in this case since the outcome is the only variable.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

If the beads in the urn is not equally sized, and the small beads can fit in the shovel will more likely to show up. In the case, the bead size is the covariate that might affect the outcome, which is the proportions of red beads in the urn. 

### Exercise 7

What are the treatments, if any, for this problem?

```{r wisdom-7}
question_text(NULL,
	message = "There is no treatment since the question we are interested in is predictive, not causal.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

<!-- Since the question we are trying to answer is not a causal problem (e.g. Does using the right hand instead of left hand to turn the urn make the red beads more likely to be selected?). Instead, we only care,   -->

### Exercise 8

What moment in time does the Preceptor Table refer to?

```{r wisdom-8}
question_text(NULL,
	message = "The moment we are considering is the time when the beads were drawn from the urn.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

<!-- Add knowledge drop about how time can be different and can affect the result (e.g. turn the urn in the morning versus in the afternoon) -->

### Exercise 9

<!-- XX: It is a feature that this question almost forces students to go to the chapter and read about the data. This entire sentence will not be included in your summary at the end of Wisdom, but bits of it will be mentioned. -->

Write one sentence describing the data you have to answer your question.

```{r wisdom-9}
question_text(NULL,
	message = "The data we have contains the color of the 50 beads drawn from the urn using the shovel. The data table has 2 columns, ID and Color, and 50 rows which represent each bead.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 10

Load the **tidyverse** package.

```{r wisdom-10, exercise = TRUE}

```

```{r wisdom-10-hint-1, eval = FALSE}
library(...)
```

```{r wisdom-10-test, include = FALSE}
library(tidyverse)
```

### 

<!-- XX: Insert comments about the data. -->

<!-- XX: Load any other packages that are needed, one package per question. (But make sure that they are also included in the setup chunk.) primer.data, for example, is often needed. But save brms and tidybayes for the Courage section. -->

<!-- XX: Add questions about EDA with your data. In particular, add at least one question about the dependent variable in the model along with one or more questions about covariates. If there is a treatment variable, you must include a question about it. -->

<!-- Variable questions come in two types. First there are questions which require the student to run, say, summary() on the variable. Then, knowledge about the variable can be dropped. Second, there are questions which ask for a one sentence summary about the variable, something which could be used in our summary of the project. For example: "Civility is measured on a 1 through 7 scale with higher values corresponding to greater civility." -->

### Exercise 11

In your own words, define "validity" as we use the term.

```{r wisdom-11}
question_text(NULL,
	message = "Validity is the consistency, or lack thereof, in the columns of the data set and the corresponding columns in the Preceptor Table.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 12

What can't we do if the assumption of validity is not true?

```{r wisdom-12}
question_text(NULL,
	message = "We can't combine the Preceptor Table and the data in order to construct the Population Table.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 13

Provide one reason why the assumption of validity might not hold for this problem.

```{r wisdom-13}
question_text(NULL,
	message = "Consider the outcome measured in our data, which is the color of the bead. Validity can be assumed in this case as the color of the beads in our data and the bead color in our Preceptor Table mean the same thing.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 14

Summarize the state of your work so far in one sentence. Make reference to the data you have and to the specific question you are trying to answer. 


```{r wisdom-14}
question_text(NULL,
	message = "Using a sample of 50 beads drawn from an urn in which all beads are either red or white, we seek to determine the proportion of beads which are red.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

## Justice
### 

*It is in justice that the ordering of society is centered.* - Aristotle


### Exercise 1

In your own words, name the four key components of Justice for working on a data science problem.

```{r justice-1}
question_text(NULL,
	message = "Justice concerns four topics: the Population Table, stability, representativeness, and unconfoundedness.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 2

In your own words, define a Population Table.

```{r justice-2}
question_text(NULL,
	message = "The Population Table includes a row for each unit/time combination in the underlying population from which both the Preceptor Table and the data are drawn.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 3

In your own words, define the assumption of "stability" when employed in the context of data science.

```{r justice-3}
question_text(NULL,
	message = "Stability means that the relationship between the columns in the Population Table is the same for three categories of rows: the data, the Preceptor Table, and the larger population from which both are drawn.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

<!-- XX: Keep just one of these two. -->

<!-- Stability is all about *time*. Is the relationship among the columns in the Population Table stable over time? In particular, is the relationship --- which is another way of saying "mathematical formula" --- at the time the data was gathered the same as the relationship at the (generally later) time references by the Preceptor Table. -->

<!-- *The longer the time period covered by the Preceptor Table (and the data), the more suspect the assumption of stability becomes.*  -->

### Exercise 4

Provide one reason why the assumption of stability might not be true in this case.

```{r justice-4}
question_text(NULL,
	message = "Consider the previous example of turning the urn in the morning versus in the afternoon. The person turning the urn might feel tired after doing this task many times in the day and thus did not turn it properly, which resulted in the fact that red beads appeared more frequently. ",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 5

In your own words, define the assumption of "representativeness" when employed in the context of data science.

```{r justice-5}
question_text(NULL,
	message = "Representativeness, or the lack thereof, concerns two relationship, among the rows in the Population Table. The first is between the Preceptor Table and the other rows. The second is between our data and the other rows.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

Stability looks across time periods. Reprentativeness looks within time periods. 

### Exercise 6

Provide one reason why the assumption of representativeness might not be true in this case.

```{r justice-6}
question_text(NULL,
	message = "The person turning the urn to collect the sample might favor red beads over white and try to take more red beads within each draw, and thus our sample is not representative of the urn.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 7

In your own words, define the assumption of "unconfoundedness" when employed in the context of data science.

```{r justice-7}
question_text(NULL,
	message = "Unconfoundedness means that the treatment assignment is independent of the potential outcomes, when we condition on pre-treatment covariates.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

Since this is a predictive question, we do not worry about unconfoundedness.

### Exercise 8

Summarize the state of your work so far in two or three sentences. Make reference to the data you have and to the question you are trying to answer. Feel free to copy from your answer at the end of the Wisdom Section. Mention one specific problem which casts doubt on your approach. 


```{r justice-8}
question_text(NULL,
	message = "Using a sample of 50 beads drawn from an urn in which all beads are either red or white, we seek to determine the proportion of beads which are red. Our estimate would be flawed if someone tried to collect red beads as much as possible when making the draw.
",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

## Courage
### 

*Courage is the commitment to begin without any guarantee of success.* - Johann Wolfgang von Goethe


### Exercise 1

In your own words, describe the components of the virtue of Courage for analyzing data.

```{r courage-1}
question_text(NULL,
	message = "Emboldened by Courage, we model the outcome variable as a function of the covariates. We test our model for consistency with the data we have. We create a Data Generating Mechanism.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 2

With 17 red beads within the sample of 50 beads, calculate the percentage of red beads in the sample. Type the formula in the chunk, pipe the result to an object called `x_bar`, type `x_bar` in a separate line and hit Run Code.

```{r courage-2, exercise = TRUE}

```

```{r courage-2-hint-1, eval = FALSE}
x_bar <- .../50
x_bar
```

```{r courage-2-test, include = FALSE}
x_bar <- 17/50
x_bar
```

### 

Common sense suggests that this is a good estimate of the center of the posterior.

### Exercise 3

In the Console, type the command `sd()` with the argument `c(rep(0, 17), rep(1, 33))`. This will return the standard deviation of the sample size.

```{r courage-3, exercise = TRUE}

```

```{r courage-3-hint-1, eval = FALSE}
...(c(...(0, 17), ...(1, 33)))
```

```{r courage-3-test, include = FALSE}
sd(c(rep(0, 17), rep(1, 33)))
```

### 

### Exercise 4

Continue with the code above, calculate the standard error. Recall that the difference between this two is that for a given sample size, the standard error equals the standard deviation divided by the square root of the sample size.

```{r courage-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r courage-4-hint-1, eval = FALSE}
... / sqrt(...)
```

```{r courage-4-test, include = FALSE}
sd(c(rep(0, 17), rep(1, 33))) / sqrt(50)
```

### 

### Exercise 5

With the standard error, calculate the 95% confidence interval for the proportion of red beads in the urn. Recall the formula for confidence interval is: 

$$ SE =  \bar{x} \pm 2SE $$

```{r courage-5}
question_text(NULL,
	message = "With 95% confidence, the proportion of red beads in the urn is between 21% and 47%.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

Recall that the outcome we are interested in, the color of the bead, can only be either red or white. The model that is used for sampling scenarios with only two possible values is called a *Bernoulli* model.

### 

## Temperance 
### 

*Temperance is a bridle of gold; he, who uses it rightly, is more like a god than a man.* - Robert Burton

### Exercise 1

In your own words, describe the use of Temperance in finishing your data science project.

```{r temperance-1}
question_text(NULL,
	message = "Temperance uses the Data Generating Mechanism to answer the question with which we began. Humility reminds us that this answer is always a lie.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

Recall the question we are trying to answer:

> Given an urn consists of 1,000 identically sized red and white beads in the urn, mixed well together. What proportion, $p$, of this urn's beads are red?

We will be creating the following graph to answer the question: 

```{r}
tibble(obs = rnorm(1000000, mean = 0.34, sd = 0.067)) |> 
  ggplot(aes(x = obs)) +
    geom_density(aes(y = after_stat(count/sum(count))))  +
    labs(title = expression(paste("Posterior Distribution for  ", rho)),
         subtitle = "There is a 95% chance for a value between 21% and 47%.",
         x = expression(paste("Proportion, ", rho, ", of Red Beads in Urn")),
         y = "Probability") +
    scale_x_continuous(labels = scales::percent_format()) +
    scale_y_continuous(labels = scales::percent_format()) +
    theme_classic()
```

### Exercise 2

Create a `tibble()` command with the argument `obs` equal `rnorm(1000000, mean = 0.34, sd = 0.067`)

```{r temperance-2, exercise = TRUE}

```

```{r temperance-2-hint-1, eval = FALSE}
tibble(... = rnorm(1000000, ... = 0.34, sd = ...))
```

```{r temperance-2-test, include = FALSE}
tibble(obs = rnorm(1000000, mean = 0.34, sd = 0.067))
```

### 

### Exercise 3

Continue the pipe with `ggplot()`, mapping `x` to `obs` in the `aes()` argument. 

```{r temperance-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r temperance-3-hint-1, eval = FALSE}
... |> 
  ggplot(...(x = ...))
```

```{r temperance-3-test, include = FALSE}
tibble(obs = rnorm(1000000, mean = 0.34, sd = 0.067)) |> 
  ggplot(aes(x = obs))
```

### 

### Exercise 4

Add `geom_density()`, setting `y` equal to `after_stat(count/sum(count))` in the `aes()` argument.

```{r temperance-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r temperance-4-hint-1, eval = FALSE}
... |> 
  ggplot(aes(x = ...)) + 
    geom_density(...(y = after_stat(.../sum(count))))
```

```{r temperance-4-test, include = FALSE}
tibble(obs = rnorm(1000000, mean = 0.34, sd = 0.067)) |> 
  ggplot(aes(x = obs)) +
    geom_density(aes(y = after_stat(count/sum(count))))
```

### 

### Exercise 5

Add `scale_x_continuous()` with the argument `labels` equal `scales::percent_format()`.

```{r temperance-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r temperance-5-hint-1, eval = FALSE}
... + 
  scale_x_continuous(... = scales::percent_format())
```

```{r temperance-5-test, include = FALSE}
tibble(obs = rnorm(1000000, mean = 0.34, sd = 0.067)) |> 
  ggplot(aes(x = obs)) +
    geom_density(aes(y = after_stat(count/sum(count)))) + 
    scale_x_continuous(labels = scales::percent_format())
```

### 

### Exercise 6

Add `scale_y_continuous()` with the argument `labels` equal `scales::percent_format()`.

```{r temperance-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r temperance-6-hint-1, eval = FALSE}
... + 
  scale_y_continuous(... = scales::percent_format())
```

```{r temperance-6-test, include = FALSE}
tibble(obs = rnorm(1000000, mean = 0.34, sd = 0.067)) |> 
  ggplot(aes(x = obs)) +
    geom_density(aes(y = after_stat(count/sum(count)))) + 
    scale_x_continuous(labels = scales::percent_format()) + 
    scale_y_continuous(labels = scales::percent_format())
```

### 

### Exercise 7

Add `theme_classic()`

```{r temperance-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r temperance-7-hint-1, eval = FALSE}
... + 
   theme_classic()
```

```{r temperance-7-test, include = FALSE}
tibble(obs = rnorm(1000000, mean = 0.34, sd = 0.067)) |> 
  ggplot(aes(x = obs)) +
    geom_density(aes(y = after_stat(count/sum(count)))) + 
    scale_x_continuous(labels = scales::percent_format()) + 
    scale_y_continuous(labels = scales::percent_format()) + 
    theme_classic()
```

### 

### Exercise 8

Finally, add `title`, `subtitle`, labels for `x` and `y` axes. Remember this is what your graph should look like. 

```{r}
tibble(obs = rnorm(1000000, mean = 0.34, sd = 0.067)) |> 
  ggplot(aes(x = obs)) +
    geom_density(aes(y = after_stat(count/sum(count))))  +
    labs(title = expression(paste("Posterior Distribution for  ", rho)),
         subtitle = "There is a 95% chance for a value between 21% and 47%.",
         x = expression(paste("Proportion, ", rho, ", of Red Beads in Urn")),
         y = "Probability") +
    scale_x_continuous(labels = scales::percent_format()) +
    scale_y_continuous(labels = scales::percent_format()) +
    theme_classic()
```

```{r temperance-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r temperance-8-hint-1, eval = FALSE}
... + 
  labs(title = expression(paste("Posterior Distribution for ", rho)), subtitle = "...", 
       x = expression(paste("Proportion, ", rho, ", of Red Beads in Urn")), y = "...")
```

```{r temperance-8-test, include = FALSE}
tibble(obs = rnorm(1000000, mean = 0.34, sd = 0.067)) |> 
  ggplot(aes(x = obs)) +
    geom_density(aes(y = after_stat(count/sum(count))))  +
    labs(title = expression(paste("Posterior Distribution for  ", rho)),
         subtitle = "There is a 95% chance for a value between 21% and 47%.",
         x = expression(paste("Proportion, ", rho, ", of Red Beads in Urn")),
         y = "Probability") +
    scale_x_continuous(labels = scales::percent_format()) +
    scale_y_continuous(labels = scales::percent_format()) +
    theme_classic()
```

### 

The percentage of red beads in the urn is about 34%, with a 95% credible interval from 21% to 47%.

### Exercise 9

Write a few sentences summarize your work to answer the question with which we began. 


```{r temperance-9}
question_text(NULL,
	message = "Using a sample of 50 beads drawn from an urn in which all beads are either red or white, we seek to determine the proportion of beads which are red. Our estimate would be flawed if someone has changed the beads in the urn since we drew our sample. We model the color of an individual bead as a draw from a Bernoulli distribution with unknown parameter. The percentage of red beads in the urn is about 34%, with a 95% credible interval from 21% to 47%.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```



## Summary
### 

This tutorial covered [Chapter 3: Sampling](https://ppbds.github.io/primer/sampling.html) of [*Preceptor’s Primer for Bayesian Data Science: Using the Cardinal Virtues for Inference*](https://ppbds.github.io/primer/) by [David Kane](https://davidkane.info/). 
 

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
