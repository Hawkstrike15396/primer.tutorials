---
title: 'Visualization: Tidyverse'
author: Heather Li and Yuhan Wu
tutorial:
  id: visualization-tidyverse
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: Overview of the most important commands in the Tidyverse.
---

<!-- Example sections require the use of multiple commands in a chain. --> 


```{r setup, include = FALSE}
library(learnr)
library(all.primer.tutorials)
library(tidyverse)
library(primer.data)
library(learnr)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = "../../child_documents/copy_button.Rmd"}
```

```{r info-section, child = "../../child_documents/info_section.Rmd"}
```

## Introduction
### 

This tutorial will walk you through some of the major functions in the **[tidyverse](https://www.tidyverse.org/)** package, including functions like `filter()` and `select()` that are useful for data manipulation, as well summary functions like `mean()` and `median()` which are important for statistical analysis.



## `filter()`
### 

Let's practice how to use `filter()` tibbles to include only the rows with attributes we want to see. 

### Exercise 1

Use `glimpse()` to look at the data set `cces`.


```{r filter-1, exercise = TRUE}

```

### Exercise 2

Start your code with `cces`. Use the pipe operator `|>` and then add the function `filter()`. Within `filter()` select the rows where `state` is equal to "Massachusetts". To set something equal to a value in `filter` use two equal signs, `==`.


```{r filter-2, exercise = TRUE}
```

```{r filter-2-hint-1, eval = FALSE}
cces |> 
  filter(state == "...")
```

### 

`==` is used because it is **checking** whether the value is equal. A single equation symbol, `=`, is used to set something equal to something else. 


### Exercise 3

<!-- DK: Way too verbose. -->

Great. Copy/paste your code from above. Let's now extend our code within `filter()` to include rows where `state` is "Massachusetts" AND where `ideology` is "Liberal". Use the "and" operator `&` to separate the conditions. 


```{r filter-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r filter-3-hint-1, eval = FALSE}
cces |> 
  filter(state == "..." &
        ideology == "...")
```

### 

Note that we maintain our `cces |>` which allows `filter()` to know the data that it manipulates with. It is also possible to not use the `|>` operator, just include the data frame `filter()` needs to deal with as the first argument in within the parentheses. For example:  `filter(cces,state == "Massachusetts" & ideology == "Liberal")`.

<!-- AB: Maybe add in something about the "or" operator -->

### Exercise 4

Start a new pipe with `cces`. Use `filter()` to include data  where both `gender` is "Male" and `age` is greater than or equal to 40. Instead of using `&` to separate the two conditions, use a comma. 

### 

```{r filter-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r filter-4-hint-1, eval = FALSE}
cces |> 
  filter(gender == "...",
           age >= 40)
```

### 

Using a comma to separate arguments in `filter()` is equivalent to using `&`. The command above returns a tibble of males who are also older than 40. 

You do not need to write `40` in quotation marks because it is an integer variable, not a character variable. The same goes for all numeric variable types (dbl, numeric). You can see a variable's type under the column in brackets. 

### Exercise 5

Start a new pipe with `cces`. `filter()`  the data for rows where `gender` is "Male" OR `age` is greater than or equal to 40. Use the "or operator" `|` to separate the conditions. 


```{r filter-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r filter-5-hint-1, eval = FALSE}
cces |> 
  filter(gender == "..." |
           age >= ...)
```

### 

This tibble has more than twice as many rows as the previous command. In addition to all the rows in the preceeding tibble, it also includes men who are younger than 40 and women over the age of 40. 

### Exercise 6

Extend your code with `|>` and use the function `arrange()` to sort by the values of `age` in ascending order. 


```{r filter-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r filter-6-hint-1, eval = FALSE}
... |>
  arrange(age)
```

### 

Everyone in the first few rows should be 18. Everyone will also be male because of the way we have filtered the data. 

We do not use quotes for the argument of `arrange()`, because it is a column that exists in our tibble. This is the case for most functions which take an existing column as an argument. 

### Exercise 7

Copy/paste your code from above. Now let's organize the tibble by values of `age` in descending order. Extend your code with `|> ` and use `arrange(desc())`.


```{r filter-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r filter-7-hint-1, eval = FALSE}
cces |> 
  ... |>
  arrange(desc(age))
```

<!-- DK: Add some knowledge -->

### Exercise 8

Start a new pipe with `cces`. Instead of just those who live in Massachusetts and have liberal ideology, let's filter the data to those who live in either Massachusetts, New Hampshire, or Vermont and have liberal ideology. Let's start with the states. While we could type `state == "..."` separated by `|` three times, this is cumbersome. Instead we can use a vector with the three state names `c("Massachusetts", "New Hampshire", "Vermont")` and the `%in%` operator in place of the `==`. 

```{r filter-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r filter-8-hint-1, eval = FALSE}
cces |> 
  filter(state %in% c("...", "...", "..."))
```

### 

Using the `==` will return a tibble but NOT the tibble with the results you are looking for. When filtering for any of several terms in a vector, always use  `%in%`.

### 

We use the `!=` to reverse the results of the `==`, i.e. to include everything except what is in the condition. We cannot do the same by adding an exclamation directly in front of the `%in%` operator. Instead, we would type  `filter(!(state %in% c("Massachusetts", "New Hampshire", "Vermont)))`. Enclosing any condition within `!()` would have the same effect. 

### Exercise 9

Copy/paste your code from above. Add a new condition with a comma, and use `filter()` the data so that we keep rows whose `ideology` is "Liberal". 


```{r filter-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r filter-9-hint-1, eval = FALSE}
cces |> 
  filter(state %in% c("...", "...", "..."),
         ideology == "Liberal")
```

### 

<!-- DK: Add knowledge. -->

### Exercise 10

Let's filter our data to just the 200 youngest liberals who live in these three states. First, continue your pipe with `|>` and use `arrange()` to arrange by age from youngest to oldest. 


```{r filter-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r filter-10-hint-1, eval = FALSE}
cces |> 
  filter(state %in% c("...", "...", "..."),
         ideology == "...") |> 
  arrange(age)

```

### Exercise 11

Because of the way we have arranged the data, the 200 rows with the lowest age value would be the first 200. Copy/paste your code from above. Continue your pipe with `|>` and use `slice()` to make a tibble of only the first two hundred rows. 


```{r filter-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r filter-11-hint-1, eval = FALSE}
Within `slice()` use the argument 1:200
```

```{r filter-11-hint-2, eval = FALSE}
cces |> 
  filter(state %in% c("Massachusetts", "New Hampshire", "Vermont"),
  ideology == "Liberal")|>
  arrange(age)|>
  slice(1:200)
```

### 

`slice(200)` instead of `slice(1:200)` will return a tibble which contains only the 200th row. 

Remember that the `:` operator represents a consecutive series, in this case of integers from 1 to 200. 

### 

Good work. 

## `select()`
### 

<!-- DK: Not a good intro. -->

Let's practice how to use `select()` tibbles to include only the columns which we want to see.  

<!-- AB: add on after the word `select()` -->

### Exercise 1

Use `glimpse()` to look at the data set `shaming`.


```{r select-1, exercise = TRUE}

```

### Exercise 2

Let's make a tibble with just the columns `sex` and `age`. Use the function `select()` which takes the column names as arguments, separated by a comma. 

```{r select-2, exercise = TRUE}

```

```{r select-2-hint-1, eval = FALSE}
shaming |> 
  select(sex, age)
```

### 

`select()` will produce the columns of the new tibble in the order specified within the function. 

As we have seen in other functions, names of existing columns does not use quatation marks.

### Exercise 3

Start a new pipe with `shaming`. The `tidyverse` uses several tools to make selecting columns easier. Use `select()` and `:` to select the columns `primary_00`, `general_00`, `primary_02`, `general_02`, `primary_04`, `general_04`. 


```{r select-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r select-3-hint-1, eval = FALSE}
As with integers, : defines a consectuive series using the first and last terms of the series. 
```

```{r select-3-hint-2, eval = FALSE}
shaming |> 
  select(primary_00:general_04)
```

### 

Notice that when selecting, unlike when filtering, R will try to suggest column names as you type. 

### Exercise 4

The `tidyverse` uses several tools to make selecting groups of columns easier. Start a new pipe with `shaming`. Use `select()` and within it the `starts_with()` helper function to select all the columns that begin with the string `"primary"`.


```{r select-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r select-4-hint-1, eval = FALSE}
shaming |> 
  select(starts_with("..."))
```

### 

We put `"primary"` in quotes because it is a string we are searching for, not the full name of an existing column.

### Exercise 5

Start a new pipe with `shaming`. Use `select()` and the helper function `contains()` to select all columns that contain an underscore `"_"`.


```{r select-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r select-5-hint-1, eval = FALSE}
shaming |> 
  select(contains("..."))
```

### 

There is a select helper function similar to `contains()` named `matches()`, which can take regular expressions with metacharacters as you have seen in Terminal with `grep`. 

### Exercise 6

Start a new pipe with `shaming`. First filter the data for rows in which the value of `primary_06` is equal to `1`.


```{r select-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r select-6-hint-1, eval = FALSE}
shaming |> 
  filter(primary_06 == ...)
```

### 

Remember that filter uses the `==` operator. 

<!-- AB: We could also use other comparative operators like "=<", "=>", ">", and "<" -->

### Exercise 7

Copy/paste your code. Now continue your pipe and select the `age` and `sex` columns. 


```{r select-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r select-7-hint-1, eval = FALSE}
shaming |> 
  filter(...) |>
  select(..., ...)
```

```{r select-7-hint-2, eval = FALSE}
shaming |> 
  filter(primary_06 == 1) |>
  select(age,sex)
```

### Exercise 8

Copy/paste your code. Now continue your pipe with the function `pull()` and set the `age` column as its argument. `pull()` selects a column and outputs its contents as a vector.


```{r select-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r select-8-hint-1, eval = FALSE}
... |> 
  pull(age)
```

### Exercise 9

Copy/paste your code. In front of `shaming` use the `<-` operator to assign the whole pipe to an object called `voter_ages`.


```{r select-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r select-9-hint-1, eval = FALSE}
voter_ages <- shaming |> 
  ... |> 
  pull(age)
```

This saves the output of all the code in the pipe, a vector of voter ages, to an object named `voter_ages`. 

### Exercise 10

Copy/paste your code. Do not continue your pipe with the pipe operator. Instead use the `mean()` function to find the mean of the vector `voter_ages`. 


```{r select-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r select-10-hint-1, eval = FALSE}
...
mean(voter_ages)
```

```{r select-10-hint-2, eval = FALSE}
voter_ages <- shaming |> 
  filter(primary_06 == 1) |>
  select(age, sex) |>
  pull(age)
 
 mean(voter_ages)
```

<!-- DK: Last knowledge drop in a Section is often a review of the highlights on that Section. -->

## `mutate()`
### 

### Exercise 1

Run `?trains` to open the help page for the data set `trains`. Read the description and peruse the column names. 

```{r mutate-1, exercise = TRUE}

```

### 

When not in a tutorial, the help page appears in the lower right corner of RStudio. 

### Exercise 2

We can also use `select()` to select columns that we want to exclude from our data. Every column that follows a `-` sign in will be excluded. Start your pipe with `trains`. Use `select()`, `-`, and a vector of the column names to exclude the columns `race`, `liberal`, `age`, `income`, `line`,  and `station`. 

```{r mutate-2, exercise = TRUE}

```

```{r mutate-2-hint-1, eval = FALSE}
... |> 
    select(-c(race, liberal, ..., ..., ..., ...))
```

### Exercise 3

The function `mutate` allows us to create new columns or change old ones by manipulating data in existing columns. Start a new pipe with `trains`. Use `mutate()` to make a new column called `age_scaled`, set this equal to the `age` column divided by 10.


```{r mutate-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r mutate-3-hint-1, eval = FALSE}
... |> 
  mutate(age_scaled = ... / ...)
```

### 

This new column does not affect the original data set `trains` unless you assign the new tibble to an object with the `<-` operator. If you were to assign it to the object `trains`, it would override the original object for your current R session. 

### Exercise 4

Copy/paste your code. Continue your pipe and use `mutate()` to create a new column called `att_change` which is equal to `att_end` minus `att_start`. 


```{r mutate-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r mutate-4-hint-1, eval = FALSE}
... |> 
  mutate(att_change = ... - ...)
```

### Exercise 5

Copy/paste your code. Let's create a new column that has the value `TRUE` when `party` is "Democrat" and `FALSE` when it is not. Continue your pipe and use `mutate()` to create a new column called `democrat`. Set `democrat` equal to an `if_else()` function. The first argument is the condition that determines your outputs, `party == "Democrat"`. The second and third arguments represents the output when the condition is true and false, respectively. Set these equal to `TRUE` and `FALSE`. 


```{r mutate-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r mutate-5-hint-1, eval = FALSE}
... |> 
  mutate(democrat = if_else(party == "Democrat", TRUE, FALSE))
```

### 

`TRUE` and `FALSE` should not be included in quotes. They are boolean type variables and can be used conveniently in many situations where character variables cannot.

### Exercise 6

Copy/paste your code. Continue your pipe and use `mutate()` to create a new column `big_hisp_perc` which returns `TRUE` when `hisp_perc` is greater than or equal to .04 and `FALSE` when it is not. 


```{r mutate-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r mutate-6-hint-1, eval = FALSE}
... |> 
  mutate(big_hisp_perc = if_else(hisp_perc > .04, TRUE, FALSE))
```

### 

Do not forget to close both opening parentheses. 

### Exercise 7

Copy/paste your code. To use mutate to edit an existing column, make the "new column" the same name as the old one. Let's make a new  `treatment` column to have value `"T"` if `treatment` is equal to `"Treated"` and `"C"` when it is not. 


```{r mutate-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r mutate-7-hint-1, eval = FALSE}
... |> 
  mutate(treatment = if_else(treatment == "Treated", "T", "C"))
```

Good work. 

## Summary functions
### 

You will practice using summary functions in R. You will learn practice how to handle missing values in a data set. 

### Exercise 1

Recall that we use the `$` operator to extract a column as a vector. Extract the column `age` from `trains`. 

```{r summary-functions-1, exercise = TRUE}

```

```{r summary-functions-1-hint-1, eval = FALSE}
trains$age
```

 
### Exercise 2

Use the `mean()` function to find the mean of the `age` column in `trains`. 


```{r summary-functions-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summary-functions-2-hint-1, eval = FALSE}
mean(trains$age)
```

### Exercise 3

Find the `median()` of the `age` column in `trains`.


```{r summary-functions-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summary-functions-3-hint-1, eval = FALSE}
median(...)
```

### 

We do not pipe summary functions together because they do not refer to each other. The function `mean()` is not performed on any data piped into it but on the object `trains$age`. 

### Exercise 4

Use the `min()` function to find the minimum of the column `age`.


```{r summary-functions-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summary-functions-4-hint-1, eval = FALSE}
min(...)
```

### Exercise 5

Find the `max()` of the column `age` in trains. 


```{r summary-functions-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summary-functions-5-hint-1, eval = FALSE}
max(...)
```

### Exercise 6

Now, try to find the `mean()` of the `pulse` column in the  `nhanes` data set. The result will be `N/A`, because these data have missing values. 


```{r summary-functions-6, exercise = TRUE}

```

```{r summary-functions-6-hint-1, eval = FALSE}
mean(nhanes$pulse)
```

### Exercise 7

Try again to find the `mean()` of the `pulse` column. To remove missing values add the argument `na.rm` and set it equal to `TRUE`. 


```{r summary-functions-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summary-functions-7-hint-1, eval = FALSE}
mean(..., na.rm = TRUE)
```

### 

`na.rm` stands for N/A **r**e**m**ove.

### Exercise 8

Let's try to use multiple summary functions at once. Use `c()` to make a vector that finds the `mean()` and `median()` of `pulse`.


```{r summary-functions-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summary-functions-8-hint-1, eval = FALSE}
Remember to set na.rm = TRUE in both functions. 
```

```{r summary-functions-8-hint-2, eval = FALSE}
c(median(..., na.rm = TRUE), 
  mean(..., na.rm = TRUE))
```

### Exercise 9

The function `quantile()` allows us to calculate percentiles of data. Let's calculate the 1st, 50th and 99th percentiles of the `pulse` column. The first argument is the vector of data for which we want to calculate, the second argument `probs` is set equal to a vector of the percentiles we want in decimal form.


```{r summary-functions-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summary-functions-9-hint-1, eval = FALSE}
Remember to include the argument, na.rm = TRUE
```

```{r summary-functions-9-hint-2, eval = FALSE}
quantile(nhanes$pulse,
         probs = c(.01, .5, .99), 
         na.rm = TRUE)
```

### Exercise 10

The functions `mad()` and `sd()` calculate the median absolute deviation and the standard deviation, both of which are measures of how spread out a function is from a central point, the median and mean, respectively. In many data sets, these values are similar. Click to continue to the exercise. 

### 

Make a vector that finds both the `mad()` and `sd()` of the `pulse` column. 


```{r summary-functions-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summary-functions-10-hint-1, eval = FALSE}
Remember to include the third argument, na.rm = TRUE in both functions. 
```

```{r summary-functions-10-hint-2, eval = FALSE}
c(mad(..., na.rm = ...), 
  sd(..., na.rm = ...))
```

Good work. 

## `summarize()` 
### 

You will learn about the `summarize()` function, which creates new tibbles with summary information of our data. 

### Exercise 1

Start a pipe with `trains`. Use `mutate()` to create a new column called `att_change` whose values is the difference between `att_end` and `att_start`. 

```{r summarize-1, exercise = TRUE}

```

```{r summarize-1-hint-1, eval = FALSE}
trains |> 
  mutate(... = att_end - att_start)
```

### Exercise 2

Copy/paste your code. The function `summarize()` is similar to `mutate()` but creates its new column in a summary table. Within the function `summarize()`, create a column named `mean_change` and set it to the `mean()` of `att_change`. 


```{r summarize-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summarize-2-hint-1, eval = FALSE}
trains |> 
  mutate(att_change = att_end - att_start) |> 
  summarize(mean_change = mean(...))
```

### Exercise 3

Copy/paste your code before the summarize function, i.e. the code in Exercise 1. `summarize()` can create a tibble with more than one new column.  Within the function `summarize()`, create a column named `mean_change` and set it to the `mean()` of `att_change` and create a column named `max_change` and set it to the `max()` of `att_change`. 


```{r summarize-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summarize-3-hint-1, eval = FALSE}
... |> 
  summarize(mean_change = mean(...), 
            max_change = max(...))
```

### 

`summarize()` must be piped directly after a tibble that has the data you want to summarize. Piping one `summarize()` function after another does not create a bigger `summarize()` table, but gives an error.

### Exercise 4

Copy/paste your code before the `summarize()` function. You can make summarize columns without assigning them names. Run the `summarize()` function with only the arguments, `mean(att_change)` and `max(att_change)`. 


```{r summarize-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summarize-4-hint-1, eval = FALSE}
... |> 
  summarize(mean(...), 
            max(...))
```

### 

If no names are given, `summarize()` will simply use the arguments as names. 

### Exercise 5

`summarize()` is not limited to just summary functions. Start a new pipe with `trains`. Use `summarize()` to create tibble with two new columns: the first, `avg_hisp_perc_scaled` which is equal to the `mean()` value of `hisp_perc` times 100; the second, `median_hisp_perc_scaled` which is equal to the `median()` value of `hisp_perc` times 100. The results will be N/A because `hisp_perc` has missing values. 


```{r summarize-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summarize-5-hint-1, eval = FALSE}
... |> 
  summarize(avg_hisp_perc_scaled = mean(hisp_perc) * ...,
            median_hisp_perc_scaled = median(hisp_perc) * ...)
```

### Exercise 6

Copy/paste the code above. Add `na.rm` in both the `median()` and `mean()` functions


```{r summarize-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summarize-6-hint-1, eval = FALSE}
... |> 
  summarize(avg_hisp_perc_scaled = mean(hisp_perc, na.rm = TRUE) * ...,
            median_hisp_perc_scaled = median(hisp_perc, na.rm = TRUE) * ...) 
```

### Exercise 7

Start a new pipe with `trains`. Use `summarize()` to make a tibble with a new column called `ideology_quantiles` which contains the 1st, 50th, and 99th percentiles of `ideology_start`. 


```{r summarize-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summarize-7-hint-1, eval = FALSE}
Remember to write probabilities in decimal form. 
```

```{r summarize-7-hint-2, eval = FALSE}
... |> 
  summarize(ideology_quantiles = quantile(ideology_start, 
                                          probs = c(..., ..., ...)))
```

### 

The summarize table should have three rows, the first corresponding to the first one of our percentiles, and so on. 

### Exercise 8

Though we know what percentiles we have calculated, this information is not in the tibble. Start a new pipe with `trains`. Use `summarize()` to make a tibble with two new columns: the first, `ideology_quantiles` which contains the 1st, 50th, and 99th percentiles of `ideology_start`; the second `percentiles` which is equal to the vector `c("1st", "50th", "99th")`.


```{r summarize-8, exercise = TRUE}
```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summarize-8-hint-1, eval = FALSE}
... |> 
  summarize(ideology_quantiles = quantile(ideology_start, 
                                          probs = c(..., ..., ...)),
            percentiles = c("...", "...", "..."))
```

### 

`summarize()`, like `mutate()`, can also create a new column which has nothing to do with the data, as we have done here with the `percentiles` column. 

### 

Good work. 

## `summarize()` with `.by`
### 

<!-- DK: This section should be expanded. -->

More commonly, we use `summarize()` to produce summary statistics not for the whole data, but for groups of data. 

### Exercise 1

Run `trains` to view the tibble. 

```{r summarize-with-by-1, exercise = TRUE}

```

### 

Notice the box in the upper left-hand corner where the dimensions are displayed. 

### Exercise 2

Copy/paste your code. Use `summarize()` to make a tibble with two new columns: the first, `avg_att_start` which contains the `mean()` of `att_start`; the second, `avg_att_end` which contains the `mean()` of `att_end`. 


```{r summarize-with-by-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summarize-with-by-2-hint-1, eval = FALSE}
... |>
  summarize(... = mean(att_start), 
            ... = mean(...))
```

### 

These are averages for the whole tibble. But what if want averages for each gender separately? For that, we use the `.by` argument to `summarize()`.

### Exercise 3

Copy/paste your code. Add a `.by` argument with the value set to `gender`. 


```{r summarize-with-by-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy to use previous code</button>

```{r summarize-with-by-3-hint-1, eval = FALSE}
... |>
  summarize(avg_att_start = mean(att_start), 
            avg_att_end = mean(att_end),
            .by = ...)
```

### 

In older R code, you may see the use of `group_by()` to accomplish this task. However, in new code, you should not use `group_by()` unless you have a very good reason to do so. 



## Summary
### 

<!-- Yuhan: Need Grammar review.  -->

These functions often look simple but are strong enough to handle almost all data sets with the help of several other functions. These functions you've learned in this chapter will becomes your friend in your exploration of R and data science. Good luck!

```{r download-answers, child = "../../child_documents/download_answers.Rmd"}
```
